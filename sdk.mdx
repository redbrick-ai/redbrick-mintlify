     Version 2.21.5       body { --color-code-background: #f8f8f8; --color-code-foreground: black; } @media not print { body\[data-theme="dark"\] { --color-code-background: #202020; --color-code-foreground: #d0d0d0; } @media (prefers-color-scheme: dark) { body:not(\[data-theme="light"\]) { --color-code-background: #202020; --color-code-foreground: #d0d0d0; } } } document.body.dataset.theme = localStorage.getItem("theme") || "auto"; Contents Menu Expand Light mode Dark mode Auto light/dark mode

Hide navigation sidebar

Hide table of contents sidebar

Toggle site navigation sidebar

[RedBrick AI](#)

Toggle Light / Dark / Auto color theme

Toggle table of contents sidebar

 [![Light Logo](/assets/logos/rbai-light.png) ![Dark Logo](/assets/logos/rbai-dark.png)

RedBrick AI](#)



*   [Python SDK](index.html#document-sdk)

*   [Command Line Interface](index.html#document-cli)

*   [Formats](index.html#document-formats/index)

    Toggle navigation of Formats

    *   [Annotation type definitions](index.html#document-formats/annotations)
    *   [Taxonomy format](index.html#document-formats/taxonomy)

[Back to top](#)

Toggle Light / Dark / Auto color theme

Toggle table of contents sidebar

RedBrick AI SDK and CLI[#](#redbrick-ai-sdk-and-cli "Link to this heading")
===========================================================================

RedBrick AI is a SaaS platform for annotating medical images. RedBrick AI provides web based annotation tools, quality control capabilities, collaboration tools, and SDK/CLI to integrate with MLOps.

Important

Please visit our [website](https://redbrickai.com) to learn more about RedBrick AI, or request for a free-trial. You can visit the platform documentation here [https://docs.redbrickai.com/](https://docs.redbrickai.com/).

The RedBrick AI SDK and CLI are useful for managing data IO operations, and programmatically interacting with the application. The CLI is best for simple operations like import and export; whereas, the SDK is best for complex operations like importing annotations, searching through data, etc.

**Installation**

The SDK and CLI are available on PyPI and can be installed using pip.

$ pip install redbrick-sdk

**Authentication**

To use the SDK and CLI, you need a API key. You can fetch the API key from the RedBrick AI dashboard, found on the right sidebar “API keys”.

![/assets/images/sdk/api.png](/assets/images/sdk/api.png)

**Organization and project ID’s**

For most methods in the CLI and SDK you will need a Project and/or Organization ID. These can be found from the URL.

![/assets/images/sdk/ids.webp](/assets/images/sdk/ids.webp)

Python SDK[#](#python-sdk "Link to this heading")
-------------------------------------------------

The SDK is best for writing Python scripts to interact with your RedBrick AI organization & projects. The SDK offers granular functions for programmatically manipulating data, importing annotations, assigning tasks, and more.

See the [Python SDK](index.html#sdk) documentation for more information.

[](index.html#sdk)

### Python SDK[#](#python-sdk "Link to this heading")

The SDK is best for writing Python scripts to interact with your RedBrick AI organization & projects. The SDK offers granular functions for programmatically manipulating data, importing annotations, assigning tasks, and more.

#### RedBrick[#](#module-redbrick "Link to this heading")

_class_ redbrick.StorageMethod[#](#redbrick.StorageMethod "Link to this definition")

Storage method integration for organizations.

*   `PUBLIC` - Access files from a public cloud storage service using their absolute URLs.

    (i.e. files available publicly)

*   `REDBRICK` - Access files stored on RedBrick AI’s servers

    (i.e. files uploaded directly to RBAI from a local machine)


_class_ Public[#](#redbrick.StorageMethod.Public "Link to this definition")

Public storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – `redbrick.StorageMethod.PUBLIC`

*   **name** (_str_) – `"Public"`

*   **details** ([_redbrick.StorageMethod.Public.Details_](index.html#redbrick.StorageMethod.Public.Details "redbrick.StorageMethod.Public.Details")) – Public storage method details.


_class_ Details[#](#redbrick.StorageMethod.Public.Details "Link to this definition")

Public storage provider details.

_property_ key_: str_[#](#redbrick.StorageMethod.Public.Details.key "Link to this definition")

Public storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.Public.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.Public.Details "redbrick.common.storage.StorageMethod.Public.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.Public.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.Public.Details.validate "Link to this definition")

Validate Public storage provider details.

Return type:

`None`

_classmethod_ from\_entity(_entity_)[#](#redbrick.StorageMethod.Public.from_entity "Link to this definition")

Get object from entity

Return type:

[`Public`](#redbrick.StorageMethod.Public "redbrick.common.storage.StorageMethod.Public")

_class_ RedBrick[#](#redbrick.StorageMethod.RedBrick "Link to this definition")

RedBrick storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – `redbrick.StorageMethod.REDBRICK`

*   **name** (_str_) – `"Direct Upload"`

*   **details** ([_redbrick.StorageMethod.RedBrick.Details_](index.html#redbrick.StorageMethod.RedBrick.Details "redbrick.StorageMethod.RedBrick.Details")) – RedBrick storage method details.


_class_ Details[#](#redbrick.StorageMethod.RedBrick.Details "Link to this definition")

RedBrick storage provider details.

_property_ key_: str_[#](#redbrick.StorageMethod.RedBrick.Details.key "Link to this definition")

RedBrick storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.RedBrick.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.RedBrick.Details "redbrick.common.storage.StorageMethod.RedBrick.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.RedBrick.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.RedBrick.Details.validate "Link to this definition")

Validate RedBrick storage provider details.

Return type:

`None`

_classmethod_ from\_entity(_entity_)[#](#redbrick.StorageMethod.RedBrick.from_entity "Link to this definition")

Get object from entity

Return type:

[`RedBrick`](#redbrick.StorageMethod.RedBrick "redbrick.common.storage.StorageMethod.RedBrick")

_class_ AWSS3(_storage\_id_, _name_, _details_)[#](#redbrick.StorageMethod.AWSS3 "Link to this definition")

AWS S3 storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – AWS S3 storage id.

*   **name** (_str_) – AWS S3 storage name.

*   **details** ([_redbrick.StorageMethod.AWSS3.Details_](index.html#redbrick.StorageMethod.AWSS3.Details "redbrick.StorageMethod.AWSS3.Details")) – AWS S3 storage method details.


_class_ Details(_bucket_, _region_, _transfer\_acceleration\=False_, _endpoint\=None_, _access\_key\_id\=None_, _secret\_access\_key\=None_, _role\_arn\=None_, _role\_external\_id\=None_, _session\_duration\=3600_)[#](#redbrick.StorageMethod.AWSS3.Details "Link to this definition")

AWS S3 storage provider details.

Variables:

*   **bucket** (_str_) – AWS S3 bucket.

*   **region** (_str_) – AWS S3 region.

*   **transfer\_acceleration** (_bool_) – AWS S3 transfer acceleration.

*   **endpoint** (_str_) – Custom endpoint (For S3 compatible storage, e.g. MinIO).

*   **access\_key\_id** (_str_) – AWS access key id.

*   **secret\_access\_key** (_str_) – AWS secret access key. (Will be None in output for security reasons)

*   **role\_arn** (_str_) – AWS assume\_role ARN. (For short-lived credentials instead of access keys)

*   **role\_external\_id** (_str_) – AWS assume\_role external id. (Will be None in output for security reasons)

*   **session\_duration** (_int_) – AWS S3 assume\_role session duration.


_property_ key_: str_[#](#redbrick.StorageMethod.AWSS3.Details.key "Link to this definition")

AWS S3 storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.AWSS3.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.AWSS3.Details "redbrick.common.storage.StorageMethod.AWSS3.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.AWSS3.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.AWSS3.Details.validate "Link to this definition")

Validate AWS S3 storage provider details.

Return type:

`None`

_class_ GoogleCloud(_storage\_id_, _name_, _details_)[#](#redbrick.StorageMethod.GoogleCloud "Link to this definition")

Google cloud storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – Google cloud storage id.

*   **name** (_str_) – Google cloud storage name.

*   **details** ([_redbrick.StorageMethod.GoogleCloud.Details_](index.html#redbrick.StorageMethod.GoogleCloud.Details "redbrick.StorageMethod.GoogleCloud.Details")) – Google cloud storage method details.


_class_ Details(_bucket_, _service\_account\_json\=None_)[#](#redbrick.StorageMethod.GoogleCloud.Details "Link to this definition")

Google cloud storage provider details.

Variables:

*   **bucket** (_str_) – GCS bucket.

*   **service\_account\_json** (_str_) – GCS service account JSON. (Will be None in output for security reasons)


_property_ key_: str_[#](#redbrick.StorageMethod.GoogleCloud.Details.key "Link to this definition")

Google cloud storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.GoogleCloud.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.GoogleCloud.Details "redbrick.common.storage.StorageMethod.GoogleCloud.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.GoogleCloud.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.GoogleCloud.Details.validate "Link to this definition")

Validate Google cloud storage provider details.

Return type:

`None`

_class_ AzureBlob(_storage\_id_, _name_, _details_)[#](#redbrick.StorageMethod.AzureBlob "Link to this definition")

Azure blob storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – Azure blob storage id.

*   **name** (_str_) – Azure blob storage name.

*   **details** ([_redbrick.StorageMethod.AzureBlob.Details_](index.html#redbrick.StorageMethod.AzureBlob.Details "redbrick.StorageMethod.AzureBlob.Details")) – Azure blob storage method details.


_class_ Details(_connection\_string\=None_, _sas\_url\=None_)[#](#redbrick.StorageMethod.AzureBlob.Details "Link to this definition")

Azure blob storage provider details.

Variables:

*   **connection\_string** (_str_) – Azure connection string. (Will be None in output for security reasons)

*   **sas\_url** (_str_) – Azure Shared Access Signature URL for granular blob access. (Will be None in output for security reasons)


_property_ key_: str_[#](#redbrick.StorageMethod.AzureBlob.Details.key "Link to this definition")

Azure blob storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.AzureBlob.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.AzureBlob.Details "redbrick.common.storage.StorageMethod.AzureBlob.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.AzureBlob.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.AzureBlob.Details.validate "Link to this definition")

Validate Azure blob storage provider details.

Return type:

`None`

_class_ AltaDB(_storage\_id_, _name_, _details_)[#](#redbrick.StorageMethod.AltaDB "Link to this definition")

AltaDB storage provider (Sub class of [`StorageProvider`](#redbrick.StorageProvider "redbrick.StorageProvider")).

Variables:

*   **storage\_id** (_str_) – AltaDB storage id.

*   **name** (_str_) – AltaDB storage name.

*   **details** ([_redbrick.StorageMethod.AltaDB.Details_](index.html#redbrick.StorageMethod.AltaDB.Details "redbrick.StorageMethod.AltaDB.Details")) – AltaDB storage method details.


_class_ Details(_access\_key\_id_, _endpoint\=None_, _secret\_access\_key\=None_)[#](#redbrick.StorageMethod.AltaDB.Details "Link to this definition")

AltaDB storage provider details.

Variables:

*   **access\_key\_id** (_str_) – AltaDB access key id.

*   **secret\_access\_key** (_str_) – AltaDB secret access key. (Will be None in output for security reasons)

*   **endpoint** (_str_) – Custom endpoint.


_property_ key_: str_[#](#redbrick.StorageMethod.AltaDB.Details.key "Link to this definition")

AltaDB storage proivder details key.

_classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageMethod.AltaDB.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageMethod.AltaDB.Details "redbrick.common.storage.StorageMethod.AltaDB.Details")

_abstract_ to\_entity()[#](#redbrick.StorageMethod.AltaDB.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

validate(_check\_secrets\=False_)[#](#redbrick.StorageMethod.AltaDB.Details.validate "Link to this definition")

Validate AltaDB storage provider details.

Return type:

`None`

_class_ redbrick.StorageProvider(_storage\_id_, _name_, _details_)[#](#redbrick.StorageProvider "Link to this definition")

Base storage provider.

##### Sub-classes:[#](#sub-classes "Link to this heading")

*   redbrick.StorageMethod.Public ([`Public`](#redbrick.StorageMethod.Public "redbrick.StorageMethod.Public"))

*   redbrick.StorageMethod.RedBrick ([`RedBrick`](#redbrick.StorageMethod.RedBrick "redbrick.StorageMethod.RedBrick"))

*   redbrick.StorageMethod.AWSS3 ([`AWSS3`](#redbrick.StorageMethod.AWSS3 "redbrick.StorageMethod.AWSS3"))

*   redbrick.StorageMethod.GoogleCloud ([`GoogleCloud`](#redbrick.StorageMethod.GoogleCloud "redbrick.StorageMethod.GoogleCloud"))

*   redbrick.StorageMethod.AzureBlob ([`AzureBlob`](#redbrick.StorageMethod.AzureBlob "redbrick.StorageMethod.AzureBlob"))

*   redbrick.StorageMethod.AltaDB ([`AltaDB`](#redbrick.StorageMethod.AltaDB "redbrick.StorageMethod.AltaDB"))


_class_ Details[#](#redbrick.StorageProvider.Details "Link to this definition")

Storage details.

_abstract property_ key_: str_[#](#redbrick.StorageProvider.Details.key "Link to this definition")

Storage proivder details key.

_abstract classmethod_ from\_entity(_entity\=None_)[#](#redbrick.StorageProvider.Details.from_entity "Link to this definition")

Get object from entity

Return type:

[`Details`](#redbrick.StorageProvider.Details "redbrick.common.storage.StorageProvider.Details")

_abstract_ to\_entity()[#](#redbrick.StorageProvider.Details.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`\[`str`, `Any`\]

_abstract_ validate(_check\_secrets\=False_)[#](#redbrick.StorageProvider.Details.validate "Link to this definition")

Validate storage provider details.

Return type:

`None`

_classmethod_ from\_entity(_entity_)[#](#redbrick.StorageProvider.from_entity "Link to this definition")

Get object from entity

Return type:

[`StorageProvider`](#redbrick.StorageProvider "redbrick.common.storage.StorageProvider")

_class_ redbrick.ImportTypes(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.ImportTypes "Link to this definition")

Enumerates the supported data import types.

Please see supported data types, and file extensions in our [documentation here](https://docs.redbrickai.com/importing-data/direct-data-upload).

_class_ redbrick.TaskEventTypes(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.TaskEventTypes "Link to this definition")

Enumerate the different types of task events.

*   `TASK_CREATED` - A new task has been created.

*   `TASK_SUBMITTED` - A task has been submitted for review.

*   `TASK_ACCEPTED` - A submitted task has been accepted in review.

*   `TASK_REJECTED` - A submitted task has been rejected in review.

*   `TASK_CORRECTED` - A submitted task has been corrected in review.

*   `TASK_ASSIGNED` - A task has been assigned to a worker.

*   `TASK_REASSIGNED` - A task has been reassigned to another worker.

*   `TASK_UNASSIGNED` - A task has been unassigned from a worker.

*   `TASK_SKIPPED` - A task has been skipped by a worker.

*   `TASK_SAVED` - A task has been saved but not yet submitted.

*   `GROUNDTRUTH_TASK_EDITED` - A ground truth task has been edited.

*   `CONSENSUS_COMPUTED` - The consensus for a task has been computed.

*   `COMMENT_ADDED` - A comment has been added to a task.

*   `CONSENSUS_TASK_EDITED` - A consensus task has been edited.


_class_ redbrick.TaskFilters(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.TaskFilters "Link to this definition")

Enumerate the different task filters.

*   `ALL` - All tasks.

*   `GROUNDTRUTH` - Ground truth tasks only.

*   `UNASSIGNED` - Tasks that have not yet been assigned to a worker.

*   `QUEUED` - Tasks that are queued for labeling/review.

*   `DRAFT` - Tasks that have been saved as draft.

*   `SKIPPED` - Tasks that have been skipped by a worker.

*   `COMPLETED` - Tasks that have been completed successfully.

*   `FAILED` - Tasks that have been rejected in review.

*   `ISSUES` - Tasks that have issues raised and cannot be completed.


_class_ redbrick.TaskStates(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.TaskStates "Link to this definition")

Task Status.

*   `UNASSIGNED` - The Task has not been assigned to a Project Admin or Member.

*   `ASSIGNED` - The Task has been assigned to a Project Admin or Member,

    but work has not begun on it.

*   `IN_PROGRESS` - The Task is currently being worked on by a Project Admin or Member.

*   `COMPLETED` - The Task has been completed successfully.

*   `PROBLEM` - A Project Admin or Member has raised an Issue regarding the Task,

    and work cannot continue until the Issue is resolved by a Project Admin.

*   `SKIPPED` - The Task has been skipped.

*   `STAGED` - The Task has been saved as a Draft.


_class_ redbrick.Stage(_stage\_name_, _config_)[#](#redbrick.Stage "Link to this definition")

Base stage.

_class_ Config[#](#redbrick.Stage.Config "Link to this definition")

Stage config.

_abstract classmethod_ from\_entity(_entity\=None_, _taxonomy\=None_)[#](#redbrick.Stage.Config.from_entity "Link to this definition")

Get object from entity

Return type:

[`Config`](#redbrick.Stage.Config "redbrick.common.stage.Stage.Config")

_abstract_ to\_entity(_taxonomy\=None_)[#](#redbrick.Stage.Config.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_abstract classmethod_ from\_entity(_entity_, _taxonomy\=None_)[#](#redbrick.Stage.from_entity "Link to this definition")

Get object from entity

Return type:

[`Stage`](#redbrick.Stage "redbrick.common.stage.Stage")

_abstract_ to\_entity(_taxonomy\=None_)[#](#redbrick.Stage.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_class_ redbrick.LabelStage(_stage\_name_, _config=<factory>_, _on\_submit=True_)[#](#redbrick.LabelStage "Link to this definition")

Label Stage.

Parameters:

*   **stage\_name** (_str_) – Stage name.

*   **on\_submit** (_Union__\[__bool__,_ _str__\]_ _\= True_) – The next stage for the task when submitted in current stage. If True, the task will go to ground truth. If False, the task will be archived.

*   **config** (_Config = Config__(__)_) – Stage config.


_class_ Config(_auto\_assignment\=None_, _auto\_assignment\_queue\_size\=None_, _show\_uploaded\_annotations\=None_, _read\_only\_labels\_edit\_access\=None_, _is\_pre\_label\=None_, _is\_consensus\_label\=None_)[#](#redbrick.LabelStage.Config "Link to this definition")

Label Stage Config.

Parameters:

*   **auto\_assignment** (_Optional__\[__bool__\]_) – Enable task auto assignment. (Default: True)

*   **auto\_assignment\_queue\_size** (_Optional__\[__int__\]_) – Task auto-assignment queue size. (Default: 5)

*   **show\_uploaded\_annotations** (_Optional__\[__bool__\]_) – Show uploaded annotations to users. (Default: True)

*   **read\_only\_labels\_edit\_access** (_Optional__\[_[_ProjectMember.Role_](index.html#redbrick.ProjectMember.Role "redbrick.ProjectMember.Role")_\]_) – Access level to change the read only labels. (Default: None)

*   **is\_pre\_label** (_Optional__\[__bool__\]_) – Is pre-labeling stage. (Default: False)

*   **is\_consensus\_label** (_Optional__\[__bool__\]_) – Is consensus-labeling stage. (Default: False)


_classmethod_ from\_entity(_entity\=None_, _taxonomy\=None_)[#](#redbrick.LabelStage.Config.from_entity "Link to this definition")

Get object from entity.

Return type:

[`Config`](#redbrick.LabelStage.Config "redbrick.stage.label.LabelStage.Config")

to\_entity(_taxonomy\=None_)[#](#redbrick.LabelStage.Config.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_classmethod_ from\_entity(_entity_, _taxonomy\=None_)[#](#redbrick.LabelStage.from_entity "Link to this definition")

Get object from entity

Return type:

[`LabelStage`](#redbrick.LabelStage "redbrick.stage.label.LabelStage")

to\_entity(_taxonomy\=None_)[#](#redbrick.LabelStage.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_class_ redbrick.ReviewStage(_stage\_name_, _config=<factory>_, _on\_accept=True_, _on\_reject=False_)[#](#redbrick.ReviewStage "Link to this definition")

Review Stage.

Parameters:

*   **stage\_name** (_str_) – Stage name.

*   **on\_accept** (_Union__\[__bool__,_ _str__\]_ _\= True_) – The next stage for the task when accepted in current stage. If True, the task will go to ground truth. If False, the task will be archived.

*   **on\_reject** (_Union__\[__bool__,_ _str__\]_ _\= False_) – The next stage for the task when rejected in current stage. If True, the task will go to ground truth. If False, the task will be archived.

*   **config** (_Config = Config__(__)_) – Stage config.


_class_ Config(_review\_percentage\=None_, _auto\_assignment\=None_, _auto\_assignment\_queue\_size\=None_, _read\_only\_labels\_edit\_access\=None_, _is\_pre\_review\=None_, _is\_consensus\_merge\=None_)[#](#redbrick.ReviewStage.Config "Link to this definition")

Review Stage Config.

Parameters:

*   **review\_percentage** (_Optional__\[__float__\]_) – Percentage of tasks in \[0, 1\] that will be sampled for review. (Default: 1)

*   **auto\_assignment** (_Optional__\[__bool__\]_) – Enable task auto assignment. (Default: True)

*   **auto\_assignment\_queue\_size** (_Optional__\[__int__\]_) – Task auto-assignment queue size. (Default: 5)

*   **read\_only\_labels\_edit\_access** (_Optional__\[_[_ProjectMember.Role_](index.html#redbrick.ProjectMember.Role "redbrick.ProjectMember.Role")_\]_) – Access level to change the read only labels. (Default: None)

*   **is\_pre\_review** (_Optional__\[__bool__\]_) – Is pre-review stage. (Default: False)

*   **is\_consensus\_merge** (_Optional__\[__bool__\]_) – Is consensus-merge (V2) stage. (Default: False)


_classmethod_ from\_entity(_entity\=None_, _taxonomy\=None_)[#](#redbrick.ReviewStage.Config.from_entity "Link to this definition")

Get object from entity.

Return type:

[`Config`](#redbrick.ReviewStage.Config "redbrick.stage.review.ReviewStage.Config")

to\_entity(_taxonomy\=None_)[#](#redbrick.ReviewStage.Config.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_classmethod_ from\_entity(_entity_, _taxonomy\=None_)[#](#redbrick.ReviewStage.from_entity "Link to this definition")

Get object from entity

Return type:

[`ReviewStage`](#redbrick.ReviewStage "redbrick.stage.review.ReviewStage")

to\_entity(_taxonomy\=None_)[#](#redbrick.ReviewStage.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_class_ redbrick.ModelStage(_stage\_name_, _config=<factory>_, _on\_submit=True_)[#](#redbrick.ModelStage "Link to this definition")

Model Stage.

Parameters:

*   **stage\_name** (_str_) – Stage name.

*   **on\_submit** (_Union__\[__bool__,_ _str__\]_ _\= True_) – The next stage for the task when submitted in current stage. If True, the task will go to ground truth. If False, the task will be archived.

*   **config** (_Config = Config__(__)_) – Stage config.


_class_ ModelTaxonomyMap[#](#redbrick.ModelStage.ModelTaxonomyMap "Link to this definition")

Model taxonomy map.

Parameters:

*   **modelCategory** (_str_) – Model category name.

*   **rbCategory** (_str_) – Category name as it appears in the RedBrick project’s taxonomy.


_class_ Config(_name_, _sub\_type\=None_, _url\=None_, _taxonomy\_objects\=None_)[#](#redbrick.ModelStage.Config "Link to this definition")

Model Stage Config.

Parameters:

*   **name** (_str_) – Model name.

*   **sub\_type** (_str_) – Model sub type.

*   **url** (_Optional__\[__str__\]_) – URL for self-hosted model.

*   **taxonomy\_objects** (_Optional__\[__List__\[_[_ModelStage.ModelTaxonomyMap_](index.html#redbrick.ModelStage.ModelTaxonomyMap "redbrick.ModelStage.ModelTaxonomyMap")_\]__\]_) – Mapping of model classes to project’s taxonomy objects.


_classmethod_ from\_entity(_entity\=None_, _taxonomy\=None_)[#](#redbrick.ModelStage.Config.from_entity "Link to this definition")

Get object from entity.

Return type:

[`Config`](#redbrick.ModelStage.Config "redbrick.stage.model.ModelStage.Config")

to\_entity(_taxonomy\=None_)[#](#redbrick.ModelStage.Config.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_classmethod_ from\_entity(_entity_, _taxonomy\=None_)[#](#redbrick.ModelStage.from_entity "Link to this definition")

Get object from entity

Return type:

[`ModelStage`](#redbrick.ModelStage "redbrick.stage.model.ModelStage")

to\_entity(_taxonomy\=None_)[#](#redbrick.ModelStage.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_class_ redbrick.OrgMember(_user\_id_, _email_, _given\_name_, _family\_name_, _role_, _tags_, _is\_2fa\_enabled_, _last\_active\=None_, _sso\_provider\=None_)[#](#redbrick.OrgMember "Link to this definition")

Organization Member.

Parameters:

*   **user\_id** (_str_) – User ID.

*   **email** (_str_) – User email.

*   **given\_name** (_str_) – User given name.

*   **family\_name** (_str_) – User family name.

*   **role** ([_OrgMember.Role_](index.html#redbrick.OrgMember.Role "redbrick.OrgMember.Role")) – User role in organization.

*   **tags** (_List__\[__str__\]_) – Tags associated with the user.

*   **is\_2fa\_enabled** (_bool_) – Whether 2FA is enabled for the user.

*   **last\_active** (_Optional__\[__datetime__\]_ _\= None_) – Last time the user was active.

*   **sso\_provider** (_Optional__\[__str__\]_ _\= None_) – User identity SSO provider.


_class_ Role(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.OrgMember.Role "Link to this definition")

Enumerate access levels for Organization.

*   `OWNER` - Organization Owner

*   `ADMIN` - Organization Admin

*   `MEMBER` - Organization Member


_classmethod_ from\_entity(_member_)[#](#redbrick.OrgMember.from_entity "Link to this definition")

Get object from entity.

Return type:

[`OrgMember`](#redbrick.OrgMember "redbrick.common.member.OrgMember")

_class_ redbrick.OrgInvite(_email_, _role_, _sso\_provider\=None_, _status\=Status.PENDING_)[#](#redbrick.OrgInvite "Link to this definition")

Organization Invite.

Parameters:

*   **email** (_str_) – User email.

*   **role** ([_OrgMember.Role_](index.html#redbrick.OrgMember.Role "redbrick.OrgMember.Role")) – User role in organization.

*   **sso\_provider** (_Optional__\[__str__\]_ _\= None_) – User identity SSO provider.

*   **status** (_OrgInvite.Status = OrgInvite.Status.PENDING_) – Invite status.


_class_ Status(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.OrgInvite.Status "Link to this definition")

Enumerate invite status.

*   `PENDING` - Pending invitation

*   `ACCEPTED` - Accepted invitation

*   `DECLINED` - Declined invitation


_classmethod_ from\_entity(_invite_)[#](#redbrick.OrgInvite.from_entity "Link to this definition")

Get object from entity.

Return type:

[`OrgInvite`](#redbrick.OrgInvite "redbrick.common.member.OrgInvite")

to\_entity()[#](#redbrick.OrgInvite.to_entity "Link to this definition")

Get entity from object.

Return type:

`Dict`

_class_ redbrick.ProjectMember(_member\_id_, _role_, _stages\=None_, _org\_membership\=None_)[#](#redbrick.ProjectMember "Link to this definition")

Project Member.

Parameters:

*   **member\_id** (_str_) – Unique user ID or email.

*   **role** ([_ProjectMember.Role_](index.html#redbrick.ProjectMember.Role "redbrick.ProjectMember.Role")) – User role in project.

*   **stages** (_Optional__\[__List__\[__str__\]__\]_ _\= None_) – Stages that the member has access to (Applicable for MEMBER role).

*   **org\_membership** (_Optional__\[_[_OrgMember_](index.html#redbrick.OrgMember "redbrick.OrgMember")_\]_ _\= None_) – Organization memberhip. This is not required when adding/updating a member.


_class_ Role(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.ProjectMember.Role "Link to this definition")

Enumerate access levels for Project.

*   `ADMIN` - Project Admin

*   `MANAGER` - Project Manager

*   `MEMBER` - Project Member (Labeler/Reviewer)


_classmethod_ from\_entity(_member_)[#](#redbrick.ProjectMember.from_entity "Link to this definition")

Get object from entity.

Return type:

[`ProjectMember`](#redbrick.ProjectMember "redbrick.common.member.ProjectMember")

redbrick.get\_org(_org\_id_, _api\_key_, _url\='https://api.redbrickai.com'_)[#](#redbrick.get_org "Link to this definition")

Get an existing redbrick organization object.

Organization object allows you to interact with your organization and perform high level actions like creating a project.

\>>> org \= redbrick.get\_org(org\_id, api\_key)

Parameters:

*   **org\_id** (_str_) – Your organizations unique id [https://app.redbrickai.com](https://app.redbrickai.com)/<org\_id>/.

*   **api\_key** (_str_) – Your secret api\_key, can be created from the RedBrick AI platform.

*   **url** (_str = DEFAULT\_URL_) – Should default to [https://api.redbrickai.com](https://api.redbrickai.com)


Return type:

[`RBOrganization`](#redbrick.RBOrganization "redbrick.common.entities.RBOrganization")

redbrick.get\_workspace(_org\_id_, _workspace\_id_, _api\_key_, _url\='https://api.redbrickai.com'_)[#](#redbrick.get_workspace "Link to this definition")

Get an existing RedBrick workspace object.

Workspace objects allow you to interact with your RedBrick AI workspaces, and perform actions like importing data, exporting data etc.

\>>> workspace \= redbrick.get\_workspace(org\_id, workspace\_id, api\_key)

Parameters:

*   **org\_id** (_str_) – Your organizations unique id [https://app.redbrickai.com](https://app.redbrickai.com)/<org\_id>/

*   **workspace\_id** (_str_) – Your workspaces unique id.

*   **api\_key** (_str_) – Your secret api\_key, can be created from the RedBrick AI platform.

*   **url** (_str = DEFAULT\_URL_) – Should default to [https://api.redbrickai.com](https://api.redbrickai.com)


Return type:

[`RBWorkspace`](#redbrick.RBWorkspace "redbrick.common.entities.RBWorkspace")

redbrick.get\_project(_org\_id_, _project\_id_, _api\_key_, _url\='https://api.redbrickai.com'_)[#](#redbrick.get_project "Link to this definition")

Get an existing RedBrick project object.

Project objects allow you to interact with your RedBrick Ai projects, and perform actions like importing data, exporting data etc.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key)

Parameters:

*   **org\_id** (_str_) – Your organizations unique id [https://app.redbrickai.com](https://app.redbrickai.com)/<org\_id>/

*   **project\_id** (_str_) – Your projects unique id [https://app.redbrickai.com](https://app.redbrickai.com)/<org\_id>/<project\_id>/

*   **api\_key** (_str_) – Your secret api\_key, can be created from the RedBrick AI platform.

*   **url** (_str = DEFAULT\_URL_) – Should default to [https://api.redbrickai.com](https://api.redbrickai.com)


Return type:

[`RBProject`](#redbrick.RBProject "redbrick.common.entities.RBProject")

redbrick.get\_org\_from\_profile(_profile\_name\=None_)[#](#redbrick.get_org_from_profile "Link to this definition")

Get the org from the profile name in credentials file

\>>> org \= get\_org\_from\_profile()

Parameters:

**profile\_name** (_str_) – Name of the profile stored in the credentials file

Return type:

[`RBOrganization`](#redbrick.RBOrganization "redbrick.common.entities.RBOrganization")

redbrick.get\_project\_from\_profile(_project\_id\=None_, _profile\_name\=None_)[#](#redbrick.get_project_from_profile "Link to this definition")

Get the RBProject object using the credentials file

project = get\_project\_from\_profile()

Parameters:

*   **project\_id** (_Optional__\[__str__\]_ _\= None_) – project id which has to be fetched. None is valid only when called within project directory.

*   **profile\_name** (_str_) – Name of the profile stored in the credentials file


Return type:

[`RBProject`](#redbrick.RBProject "redbrick.common.entities.RBProject")

#### Organization[#](#organization "Link to this heading")

_class_ redbrick.RBOrganization[#](#redbrick.RBOrganization "Link to this definition")

Bases: `ABC`

Representation of RedBrick organization.

The [`redbrick.RBOrganization`](#redbrick.RBOrganization "redbrick.RBOrganization") object allows you to programmatically interact with your RedBrick organization. This class provides methods for querying your organization and doing other high level actions. Retrieve the organization object in the following way:

Variables:

*   **team** ([_redbrick.common.member.Team_](index.html#redbrick.common.member.Team "redbrick.common.member.Team")) – Organization team management.

*   **storage** ([_redbrick.common.storage.Storage_](index.html#redbrick.common.storage.Storage "redbrick.common.storage.Storage")) – Organization storage methods integration.


\>>> org \= redbrick.get\_org(org\_id\="", api\_key\="")

_abstract property_ org\_id_: str_[#](#redbrick.RBOrganization.org_id "Link to this definition")

Retrieve the unique org\_id of this organization.

_abstract property_ name_: str_[#](#redbrick.RBOrganization.name "Link to this definition")

Retrieve unique name of this organization.

_abstract_ taxonomies(_only\_name\=True_)[#](#redbrick.RBOrganization.taxonomies "Link to this definition")

Get a list of taxonomy names/objects in the organization.

Return type:

`Union`\[`List`\[`str`\], `List`\[[`Taxonomy`](index.html#redbrick.types.taxonomy.Taxonomy "redbrick.types.taxonomy.Taxonomy")\]\]

_abstract_ workspaces\_raw()[#](#redbrick.RBOrganization.workspaces_raw "Link to this definition")

Get a list of active workspaces as raw objects in the organization.

Return type:

`List`\[`Dict`\]

_abstract_ projects\_raw()[#](#redbrick.RBOrganization.projects_raw "Link to this definition")

Get a list of active projects as raw objects in the organization.

Return type:

`List`\[`Dict`\]

_abstract_ projects()[#](#redbrick.RBOrganization.projects "Link to this definition")

Get a list of active projects in the organization.

Return type:

`List`\[[`RBProject`](#redbrick.RBProject "redbrick.common.entities.RBProject")\]

_abstract_ create\_workspace(_name_, _exists\_okay\=False_)[#](#redbrick.RBOrganization.create_workspace "Link to this definition")

Create a workspace within the organization.

This method creates a worspace in a similar fashion to the quickstart on the RedBrick AI create workspace page.

Parameters:

*   **name** (_str_) – A unique name for your workspace

*   **exists\_okay** (_bool = False_) – Allow workspaces with the same name to be returned instead of trying to create a new workspace. Useful for when running the same script repeatedly when you do not want to keep creating new workspaces.


Returns:

A RedBrick Workspace object.

Return type:

[redbrick.RBWorkspace](index.html#redbrick.RBWorkspace "redbrick.RBWorkspace")

_abstract_ create\_project\_advanced(_name_, _taxonomy\_name_, _stages_, _exists\_okay\=False_, _workspace\_id\=None_, _sibling\_tasks\=None_, _consensus\_settings\=None_)[#](#redbrick.RBOrganization.create_project_advanced "Link to this definition")

Create a project within the organization.

This method creates a project in a similar fashion to the quickstart on the RedBrick AI create project page.

Parameters:

*   **name** (_str_) – A unique name for your project

*   **taxonomy\_name** (_str_) – The name of the taxonomy you want to use for this project. Taxonomies can be found on the left side bar of the platform.

*   **stages** (_List__\[_[_Stage_](index.html#redbrick.Stage "redbrick.Stage")_\]_) – List of stage configs.

*   **exists\_okay** (_bool = False_) – Allow projects with the same name to be returned instead of trying to create a new project. Useful for when running the same script repeatedly when you do not want to keep creating new projects.

*   **workspace\_id** (_Optional__\[__str__\]_ _\= None_) – The id of the workspace that you want to add this project to.

*   **sibling\_tasks** (_Optional__\[__int__\]_ _\= None_) – Number of tasks created for each uploaded datapoint.

*   **consensus\_settings** (_Optional__\[__Dict__\[__str__,_ _Any__\]__\]_ _\= None_) –

    Consensus settings for the project. It has keys:

    *   minAnnotations: int

    *   autoAcceptThreshold?: float (range \[0, 1\])



Returns:

A RedBrick Project object.

Return type:

[redbrick.RBProject](index.html#redbrick.RBProject "redbrick.RBProject")

Raises:

**ValueError:** – If a project with the same name exists but has a different type or taxonomy.

_abstract_ create\_project(_name_, _taxonomy\_name_, _reviews\=0_, _exists\_okay\=False_, _workspace\_id\=None_, _sibling\_tasks\=None_, _consensus\_settings\=None_)[#](#redbrick.RBOrganization.create_project "Link to this definition")

Create a project within the organization.

This method creates a project in a similar fashion to the quickstart on the RedBrick AI create project page.

Parameters:

*   **name** (_str_) – A unique name for your project

*   **taxonomy\_name** (_str_) – The name of the taxonomy you want to use for this project. Taxonomies can be found on the left side bar of the platform.

*   **reviews** (_int = 0_) – The number of review stages that you want to add after the label stage.

*   **exists\_okay** (_bool = False_) – Allow projects with the same name to be returned instead of trying to create a new project. Useful for when running the same script repeatedly when you do not want to keep creating new projects.

*   **workspace\_id** (_Optional__\[__str__\]_ _\= None_) – The id of the workspace that you want to add this project to.

*   **sibling\_tasks** (_Optional__\[__int__\]_ _\= None_) – Number of tasks created for each uploaded datapoint.

*   **consensus\_settings** (_Optional__\[__Dict__\[__str__,_ _Any__\]__\]_ _\= None_) –

    Consensus settings for the project. It has keys:

    *   minAnnotations: int

    *   autoAcceptThreshold?: float (range \[0, 1\])



Returns:

A RedBrick Project object.

Return type:

[redbrick.RBProject](index.html#redbrick.RBProject "redbrick.RBProject")

Raises:

**ValueError:** – If a project with the same name exists but has a different type or taxonomy.

_abstract_ get\_project(_project\_id\=None_, _name\=None_)[#](#redbrick.RBOrganization.get_project "Link to this definition")

Get project by id/name.

Return type:

[`RBProject`](#redbrick.RBProject "redbrick.common.entities.RBProject")

_abstract_ delete\_project(_project\_id_)[#](#redbrick.RBOrganization.delete_project "Link to this definition")

Delete a project by ID.

Return type:

`bool`

_abstract_ labeling\_time(_start\_date_, _end\_date_, _concurrency\=50_)[#](#redbrick.RBOrganization.labeling_time "Link to this definition")

Get information of tasks labeled between two dates (both inclusive).

Return type:

`List`\[`Dict`\]

_abstract_ create\_taxonomy(_name_, _study\_classify\=None_, _series\_classify\=None_, _instance\_classify\=None_, _object\_types\=None_)[#](#redbrick.RBOrganization.create_taxonomy "Link to this definition")

Create a Taxonomy V2.

Parameters:

*   **name** (`str`) – Unique identifier for the taxonomy.

*   **study\_classify** (`Optional`\[`List`\[[`Attribute`](index.html#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]\]) – Study level classification applies to the task.

*   **series\_classify** (`Optional`\[`List`\[[`Attribute`](index.html#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]\]) – Series level classification applies to a single series within a task.

*   **instance\_classify** (`Optional`\[`List`\[[`Attribute`](index.html#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]\]) – Instance classification applies to a single frame (video) or slice (3D volume).

*   **object\_types** (`Optional`\[`List`\[[`ObjectType`](index.html#redbrick.types.taxonomy.ObjectType "redbrick.types.taxonomy.ObjectType")\]\]) – Object types are used to annotate features/objects in tasks, for example, segmentation or bounding boxes.


Raises:

**ValueError:** – If there are validation errors.

Return type:

`None`

_abstract_ get\_taxonomy(_name\=None_, _tax\_id\=None_)[#](#redbrick.RBOrganization.get_taxonomy "Link to this definition")

Get a taxonomy created in your organization based on id or name.

Format reference for categories and attributes objects: [https://sdk.redbrickai.com/formats/taxonomy.html](https://sdk.redbrickai.com/formats/taxonomy.html)

Return type:

[`Taxonomy`](index.html#redbrick.types.taxonomy.Taxonomy "redbrick.types.taxonomy.Taxonomy")

_abstract_ update\_taxonomy(_tax\_id_, _study\_classify\=None_, _series\_classify\=None_, _instance\_classify\=None_, _object\_types\=None_)[#](#redbrick.RBOrganization.update_taxonomy "Link to this definition")

Update the categories/attributes of Taxonomy (V2) in the organization.

Format reference for categories and attributes objects: [https://sdk.redbrickai.com/formats/taxonomy.html](https://sdk.redbrickai.com/formats/taxonomy.html)

Raises:

**ValueError:** – If there are validation errors.

Return type:

`None`

_abstract_ delete\_taxonomy(_name\=None_, _tax\_id\=None_)[#](#redbrick.RBOrganization.delete_taxonomy "Link to this definition")

Delete a taxonomy by name or ID.

Return type:

`bool`

#### Team[#](#team "Link to this heading")

_class_ redbrick.common.member.Team[#](#redbrick.common.member.Team "Link to this definition")

Bases: `ABC`

Abstract interface to Team module.

_abstract_ get\_member(_member\_id_)[#](#redbrick.common.member.Team.get_member "Link to this definition")

Get a team member.

org \= redbrick.get\_org(org\_id, api\_key)
member \= org.team.get\_member(member\_id)

Parameters:

**member\_id** (_str_) – Unique member userId or email.

Return type:

[OrgMember](index.html#redbrick.OrgMember "redbrick.common.member.OrgMember")

_abstract_ list\_members()[#](#redbrick.common.member.Team.list_members "Link to this definition")

Get a list of all organization members.

org \= redbrick.get\_org(org\_id, api\_key)
members \= org.team.list\_members()

Return type:

List\[[OrgMember](index.html#redbrick.OrgMember "redbrick.common.member.OrgMember")\]

_abstract_ remove\_members(_member\_ids_)[#](#redbrick.common.member.Team.remove_members "Link to this definition")

Remove members from the organization.

org \= redbrick.get\_org(org\_id, api\_key)
org.team.remove\_members(member\_ids)

Parameters:

**member\_ids** (_List__\[__str__\]_) – Unique member ids (userId or email).

Return type:

`None`

_abstract_ list\_invites()[#](#redbrick.common.member.Team.list_invites "Link to this definition")

Get a list of all pending or declined invites.

org \= redbrick.get\_org(org\_id, api\_key)
members \= org.team.list\_invites()

Return type:

List\[[OrgInvite](index.html#redbrick.OrgInvite "redbrick.common.member.OrgInvite")\]

_abstract_ invite\_user(_invitation_)[#](#redbrick.common.member.Team.invite_user "Link to this definition")

Invite a user to the organization.

org \= redbrick.get\_org(org\_id, api\_key)
invitation \= org.team.invite\_user(OrgInvite(email\="...", role\=OrgMember.Role.MEMBER))

Parameters:

**invitation** ([_OrgInvite_](index.html#redbrick.OrgInvite "redbrick.common.member.OrgInvite")) – Organization invite

Return type:

[OrgInvite](index.html#redbrick.OrgInvite "redbrick.common.member.OrgInvite")

_abstract_ revoke\_invitation(_invitation_)[#](#redbrick.common.member.Team.revoke_invitation "Link to this definition")

Revoke org user invitation.

org \= redbrick.get\_org(org\_id, api\_key)
org.team.revoke\_invitation(OrgInvite(email\="..."))

Parameters:

**invitation** ([_OrgInvite_](index.html#redbrick.OrgInvite "redbrick.common.member.OrgInvite")) – Organization invite

Return type:

`None`

#### Storage[#](#storage "Link to this heading")

_class_ redbrick.common.storage.Storage[#](#redbrick.common.storage.Storage "Link to this definition")

Bases: `ABC`

Storage Method Controller.

_abstract_ get\_storage(_storage\_id_)[#](#redbrick.common.storage.Storage.get_storage "Link to this definition")

Get a storage method by ID.

Return type:

[`StorageProvider`](#redbrick.StorageProvider "redbrick.common.storage.StorageProvider")

_abstract_ list\_storages()[#](#redbrick.common.storage.Storage.list_storages "Link to this definition")

Get a list of storage methods in the organization.

Return type:

`List`\[[`StorageProvider`](#redbrick.StorageProvider "redbrick.common.storage.StorageProvider")\]

_abstract_ create\_storage(_storage_)[#](#redbrick.common.storage.Storage.create_storage "Link to this definition")

Create a storage method.

Return type:

[`StorageProvider`](#redbrick.StorageProvider "redbrick.common.storage.StorageProvider")

_abstract_ update\_storage(_storage\_id_, _details_)[#](#redbrick.common.storage.Storage.update_storage "Link to this definition")

Update a storage method.

Return type:

[`StorageProvider`](#redbrick.StorageProvider "redbrick.common.storage.StorageProvider")

_abstract_ delete\_storage(_storage\_id_)[#](#redbrick.common.storage.Storage.delete_storage "Link to this definition")

Delete a storage method.

Return type:

`bool`

_abstract_ verify\_storage(_storage\_id_, _path_)[#](#redbrick.common.storage.Storage.verify_storage "Link to this definition")

Verify a storage method by ID.

Return type:

`bool`

#### Workspace[#](#workspace "Link to this heading")

_class_ redbrick.RBWorkspace[#](#redbrick.RBWorkspace "Link to this definition")

Bases: `ABC`

Interface for interacting with your RedBrick AI Workspaces.

_abstract property_ org\_id_: str_[#](#redbrick.RBWorkspace.org_id "Link to this definition")

Read only property.

Retrieves the unique Organization UUID that this workspace belongs to

_abstract property_ workspace\_id_: str_[#](#redbrick.RBWorkspace.workspace_id "Link to this definition")

Read only property.

Retrieves the unique Workspace ID UUID.

_abstract property_ name_: str_[#](#redbrick.RBWorkspace.name "Link to this definition")

Read only name property.

Retrieves the workspace name.

_abstract property_ metadata\_schema_: List\[Dict\]_[#](#redbrick.RBWorkspace.metadata_schema "Link to this definition")

Retrieves the workspace metadata schema.

_abstract property_ classification\_schema_: List\[Dict\]_[#](#redbrick.RBWorkspace.classification_schema "Link to this definition")

Retrieves the workspace classification schema.

_abstract property_ cohorts_: List\[Dict\]_[#](#redbrick.RBWorkspace.cohorts "Link to this definition")

Retrieves the workspace cohorts.

_abstract_ update\_schema(_metadata\_schema\=None_, _classification\_schema\=None_)[#](#redbrick.RBWorkspace.update_schema "Link to this definition")

Update workspace metadata and classification schema.

Return type:

`None`

_abstract_ update\_cohorts(_cohorts_)[#](#redbrick.RBWorkspace.update_cohorts "Link to this definition")

Update workspace cohorts.

Return type:

`None`

_abstract_ get\_datapoints(_\*_, _concurrency\=10_)[#](#redbrick.RBWorkspace.get_datapoints "Link to this definition")

Get datapoints in a workspace.

Return type:

`Iterator`\[`Dict`\]

_abstract_ archive\_datapoints(_dp\_ids_)[#](#redbrick.RBWorkspace.archive_datapoints "Link to this definition")

Archive datapoints.

Return type:

`None`

_abstract_ unarchive\_datapoints(_dp\_ids_)[#](#redbrick.RBWorkspace.unarchive_datapoints "Link to this definition")

Unarchive datapoints.

Return type:

`None`

_abstract_ add\_datapoints\_to\_cohort(_cohort\_name_, _dp\_ids_)[#](#redbrick.RBWorkspace.add_datapoints_to_cohort "Link to this definition")

Add datapoints to a cohort.

Return type:

`None`

_abstract_ remove\_datapoints\_from\_cohort(_cohort\_name_, _dp\_ids_)[#](#redbrick.RBWorkspace.remove_datapoints_from_cohort "Link to this definition")

Remove datapoints from a cohort.

Return type:

`None`

_abstract_ update\_datapoint\_attributes(_dp\_id_, _attributes_)[#](#redbrick.RBWorkspace.update_datapoint_attributes "Link to this definition")

Update datapoint attributes.

Return type:

`None`

_abstract_ add\_datapoints\_to\_projects(_project\_ids_, _dp\_ids_, _is\_ground\_truth\=False_)[#](#redbrick.RBWorkspace.add_datapoints_to_projects "Link to this definition")

Add datapoints to project.

Parameters:

*   **project\_ids** (_List__\[__str__\]_) – The projects in which you’d like to add the given datapoints.

*   **dp\_ids** (_List__\[__str__\]_) – List of datapoints that need to be added to projects.

*   **is\_ground\_truth** (_bool = False_) – Whether to create tasks directly in ground truth stage.


Return type:

`None`

_abstract_ create\_datapoints(_storage\_id_, _points_, _\*_, _concurrency\=50_)[#](#redbrick.RBWorkspace.create_datapoints "Link to this definition")

Create datapoints in workspace.

Upload data to your workspace (without annotations). Please visit [our documentation](https://sdk.redbrickai.com/formats/index.html#import) to understand the format for `points`.

workspace \= redbrick.get\_workspace(org\_id, workspace\_id, api\_key, url)
points \= \[
    {
        "name": "...",
        "series": \[
            {
                "items": "...",
            }
        \]
    }
\]
workspace.create\_datapoints(storage\_id, points)

Parameters:

*   **storage\_id** (_str_) – Your RedBrick AI external storage\_id. This can be found under the Storage Tab on the RedBrick AI platform. To directly upload images to rbai, use redbrick.StorageMethod.REDBRICK.

*   **points** (List\[[`InputTask`](index.html#redbrick.types.task.InputTask "redbrick.types.task.InputTask")\]) – Please see the RedBrick AI reference documentation for overview of the format. [https://sdk.redbrickai.com/formats/index.html#import](https://sdk.redbrickai.com/formats/index.html#import). Fields with annotation information are not supported in workspace.

*   **concurrency** (_int = 50_) –


Returns:

List of datapoint objects with key response if successful, else error

Return type:

List\[Dict\]

Note

1\. If doing direct upload, please use `redbrick.StorageMethod.REDBRICK` as the storage id. Your items path must be a valid path to a locally stored image.

2\. When doing direct upload i.e. `redbrick.StorageMethod.REDBRICK`, if you didn’t specify a “name” field in your datapoints object, we will assign the “items” path to it.

_abstract_ update\_datapoints\_metadata(_storage\_id_, _points_)[#](#redbrick.RBWorkspace.update_datapoints_metadata "Link to this definition")

Update datapoints metadata.

Update metadata for datapoints in workspace.

workspace \= redbrick.get\_workspace(org\_id, workspace\_id, api\_key, url)
points \= \[
    {
        "dpId": "...",
        "metaData": {
            "property": "value",
        }
    }
\]
workspace.update\_datapoints\_metadata(storage\_id, points)

Parameters:

*   **storage\_id** (_str_) – Storage method where the datapoints are stored.

*   **points** (List\[[`InputTask`](index.html#redbrick.types.task.InputTask "redbrick.types.task.InputTask")\]) – List of datapoints with dpId and metaData values.


Return type:

`None`

_abstract_ delete\_datapoints(_dp\_ids_, _concurrency\=50_)[#](#redbrick.RBWorkspace.delete_datapoints "Link to this definition")

Delete workspace datapoints based on ids.

\>>> workspace \= redbrick.get\_workspace(org\_id, workspace\_id, api\_key, url)
\>>> workspace.delete\_datapoints(\[...\])

Parameters:

*   **dp\_ids** (_List__\[__str__\]_) – List of datapoint ids to delete.

*   **concurrency** (_int = 50_) – The number of datapoints to delete at a time. We recommend keeping this <= 50.


Returns:

True if successful, else False.

Return type:

bool

#### Project[#](#project "Link to this heading")

_class_ redbrick.RBProject[#](#redbrick.RBProject "Link to this definition")

Bases: `ABC`

Abstract interface to RBProject.

Variables:

*   **upload** ([_redbrick.common.upload.Upload_](index.html#redbrick.common.upload.Upload "redbrick.common.upload.Upload")) – Upload data to project.

*   **labeling** ([_redbrick.common.labeling.Labeling_](index.html#redbrick.common.labeling.Labeling "redbrick.common.labeling.Labeling")) – Labeling activities.

*   **review** ([_redbrick.common.labeling.Labeling_](index.html#redbrick.common.labeling.Labeling "redbrick.common.labeling.Labeling")) – Review activities.

*   **export** ([_redbrick.common.export.Export_](index.html#redbrick.common.export.Export "redbrick.common.export.Export")) – Project data export.

*   **settings** ([_redbrick.common.settings.Settings_](index.html#redbrick.common.settings.Settings "redbrick.common.settings.Settings")) – Project settings management.

*   **workforce** ([_redbrick.common.member.Workforce_](index.html#redbrick.common.member.Workforce "redbrick.common.member.Workforce")) – Project workforce management.


\>>> project \= redbrick.get\_project(org\_id\="", project\_id\="", api\_key\="")

_abstract property_ org\_id_: str_[#](#redbrick.RBProject.org_id "Link to this definition")

Read only property.

Retrieves the unique Organization UUID that this project belongs to

_abstract property_ project\_id_: str_[#](#redbrick.RBProject.project_id "Link to this definition")

Read only property.

Retrieves the unique Project ID UUID.

_abstract property_ name_: str_[#](#redbrick.RBProject.name "Link to this definition")

Read only name property.

Retrieves the project name.

_abstract property_ url_: str_[#](#redbrick.RBProject.url "Link to this definition")

Read only property.

Retrieves the project URL.

_abstract property_ taxonomy\_name_: str_[#](#redbrick.RBProject.taxonomy_name "Link to this definition")

Read only taxonomy\_name property.

Retrieves the taxonomy name.

_abstract property_ taxonomy_: [Taxonomy](index.html#redbrick.types.taxonomy.Taxonomy "redbrick.types.taxonomy.Taxonomy")_[#](#redbrick.RBProject.taxonomy "Link to this definition")

Retrieves the project taxonomy.

_abstract property_ workspace\_id_: str | None_[#](#redbrick.RBProject.workspace_id "Link to this definition")

Read only workspace\_id property.

Retrieves the workspace id.

_abstract property_ label\_storage_: Tuple\[str, str\]_[#](#redbrick.RBProject.label_storage "Link to this definition")

Read only label\_storage property.

Retrieves the label storage id and path.

_abstract property_ stages_: List\[[Stage](index.html#redbrick.Stage "redbrick.common.stage.Stage")\]_[#](#redbrick.RBProject.stages "Link to this definition")

Get list of stages.

_abstract_ set\_label\_storage(_storage\_id_, _path_)[#](#redbrick.RBProject.set_label_storage "Link to this definition")

Set label storage method for a project.

By default, all annotations get stored in RedBrick AI’s storage i.e. `redbrick.StorageMethod.REDBRICK`. Set a custom external storage, within which RedBrick AI will write all annotations.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key)
\>>> project.set\_label\_storage(storage\_id)

Parameters:

*   **storage\_id** (_str_) – The unique ID of your RedBrick AI storage method integration. Found on the storage method tab on the left sidebar.

*   **path** (_str_) – A prefix path within which the annotations will be written.


Returns:

Returns \[storage\_id, path\]

Return type:

Tuple\[str, str\]

Important

You only need to run this command once per project.

Raises:

**ValueError:** – If there are validation errors.

_abstract_ update\_stage(_stage_)[#](#redbrick.RBProject.update_stage "Link to this definition")

Update stage.

Return type:

`None`

#### Export[#](#export "Link to this heading")

_class_ redbrick.common.export.Export[#](#redbrick.common.export.Export "Link to this definition")

Bases: `ABC`

Primary interface for various export methods.

The export module has many functions for exporting annotations and meta-data from projects. The export module is available from the [`redbrick.RBProject`](#redbrick.RBProject "redbrick.RBProject") module.

\>>> project \= redbrick.get\_project(api\_key\="", org\_id\="", project\_id\="")
\>>> project.export \# Export

_abstract_ export\_tasks(_\*_, _concurrency\=10_, _only\_ground\_truth\=False_, _stage\_name\=None_, _task\_id\=None_, _from\_timestamp\=None_, _old\_format\=False_, _without\_masks\=False_, _without\_json\=False_, _semantic\_mask\=False_, _binary\_mask\=None_, _no\_consensus\=None_, _with\_files\=False_, _dicom\_to\_nifti\=False_, _png\=False_, _rt\_struct\=False_, _mhd\=False_, _destination\=None_)[#](#redbrick.common.export.Export.export_tasks "Link to this definition")

Export annotation data.

Meta-data and category information returned as an Object. Segmentations are written to your disk in NIfTI-1 format. Please [visit our documentation](https://sdk.redbrickai.com/formats/index.html#export) for more information on the format.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
\>>> project.export.export\_tasks()

Parameters:

*   **concurrency** (_int = 10_) –

*   **only\_ground\_truth** (_bool = False_) – If set to True, will only return data that has been completed in your workflow. If False, will export latest state.

*   **stage\_name** (_Optional__\[__str__\]_ _\= None_) – If set, will only export tasks that are currently in the given stage.

*   **task\_id** (_Optional__\[__str__\]_ _\= None_) – If the unique task\_id is mentioned, only a single datapoint will be exported.

*   **from\_timestamp** (_Optional__\[__float__\]_ _\= None_) – If the timestamp is mentioned, will only export tasks that were labeled/updated since the given timestamp. Format - output from datetime.timestamp()

*   **old\_format** (_bool = False_) – Whether to export tasks in old format.

*   **without\_masks** (_bool = False_) – Exports only tasks JSON without downloading any segmentation masks. Note: This is not recommended for tasks with overlapping labels.

*   **without\_json** (_bool = False_) – Doesn’t create the tasks JSON file.

*   **semantic\_mask** (_bool = False_) – Whether to export all segmentations as semantic\_mask. This will create one instance per class. If this is set to True and a task has multiple instances per class, then attributes belonging to each instance will not be exported.

*   **binary\_mask** (_Optional__\[__bool__\]_ _\= None_) – Whether to export all segmentations as binary masks. This will create one segmentation file per instance. If this is set to None and a task has overlapping labels, then binary\_mask option will be True for that particular task.

*   **no\_consensus** (_Optional__\[__bool__\]_ _\= None_) – Whether to export tasks without consensus info. If None, will default to export with consensus info, if it is enabled for the given project. (Applicable only for new format export)

*   **with\_files** (_bool = False_) – Export with files (e.g. images/video frames)

*   **dicom\_to\_nifti** (_bool = False_) – Convert DICOM images to NIfTI. Applicable when with\_files is True.

*   **png** (_bool = False_) – Export labels as PNG masks.

*   **rt\_struct** (_bool = False_) – Export labels as DICOM RT-Struct. (Only for DICOM images)

*   **mhd** (_bool = False_) – Export segmentation masks in MHD format.

*   **destination** (_Optional__\[__str__\]_ _\= None_) – Destination directory (Default: current directory)


Returns:

Datapoint and labels in RedBrick AI format. See [https://sdk.redbrickai.com/formats/index.html#export](https://sdk.redbrickai.com/formats/index.html#export)

Return type:

Iterator\[[`OutputTask`](index.html#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")\]

Note

If both semantic\_mask and binary\_mask options are True, then one binary mask will be generated per class.

_abstract_ list\_tasks(_search\=TaskFilters.ALL_, _concurrency\=10_, _limit\=50_, _\*_, _stage\_name\=None_, _user\_id\=None_, _task\_id\=None_, _task\_name\=None_, _exact\_match\=False_, _completed\_at\=None_)[#](#redbrick.common.export.Export.list_tasks "Link to this definition")

Search tasks based on multiple queries for a project. This function returns minimal meta-data about the queried tasks.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
\>>> result \= project.export.list\_tasks()

Parameters:

*   **search** ([`TaskFilters`](#redbrick.TaskFilters "redbrick.common.enums.TaskFilters") = TaskFilters.ALL) – Task filter type.

*   **concurrency** (_int = 10_) – The number of requests that will be made in parallel.

*   **limit** (_Optional__\[__int__\]_ _\= 50_) – The number of tasks to return. Use None to return all tasks matching the search query.

*   **stage\_name** (_Optional__\[__str__\]_ _\= None_) –

    If present, will return tasks that are:

    1.  Available in stage\_name: If search == TaskFilters.QUEUED

    2.  Completed in stage\_name: If search == TaskFilters.COMPLETED


*   **user\_id** (_Optional__\[__str__\]_ _\= None_) –

    User id/email. If present, will return tasks that are:

    1.  Assigned to user\_id: If search == TaskFilters.QUEUED

    2.  Completed by user\_id: If search == TaskFilters.COMPLETED


*   **task\_id** (_Optional__\[__str__\]_ _\= None_) – If present, will return data for the given task id.

*   **task\_name** (_Optional__\[__str__\]_ _\= None_) – If present, will return data for the given task name. This will do a prefix search with the given task name.

*   **exact\_match** (_bool = False_) – Applicable when searching for tasks by task\_name. If True, will do a full match instead of partial match.

*   **completed\_at** (_Optional__\[__Tuple__\[__Optional__\[__float__\]__,_ _Optional__\[__float__\]__\]__\]_ _\= None_) – If present, will return tasks that were completed in the given time range. The tuple contains the from and to timestamps respectively.


Returns:

\>>> \[{
    "taskId": str,
    "name": str,
    "createdAt": str,
    "updatedAt": str,
    "currentStageName": str,
    "createdBy"?: {"userId": str, "email": str},
    "priority"?: float(\[0, 1\]),
    "metaData"?: dict,
    "series"?: \[{"name"?: str, "metaData"?: dict}\],
    "assignees"?: \[{
        "user": str,
        "status": TaskStates,
        "assignedAt": datetime,
        "lastSavedAt"?: datetime,
        "completedAt"?: datetime,
        "timeSpentMs"?: float,
    }\]
}\]

Return type:

Iterator\[Dict\]

_abstract_ get\_task\_events(_\*_, _task\_id\=None_, _only\_ground\_truth\=True_, _concurrency\=10_, _from\_timestamp\=None_, _with\_labels\=False_)[#](#redbrick.common.export.Export.get_task_events "Link to this definition")

Generate an audit log of all actions performed on tasks.

Use this method to get a detailed summary of all the actions performed on your tasks, including:

*   Who uploaded the data

*   Who annotated your tasks

*   Who reviewed your tasks

*   and more.


This can be particulary useful to present to auditors who are interested in your quality control workflows.

Parameters:

*   **task\_id** (_Optional__\[__str__\]_ _\= None_) – If set, returns events only for the given task.

*   **only\_ground\_truth** (_bool = True_) – If set to True, will return events for tasks that have been completed in your workflow.

*   **concurrency** (_int = 10_) – The number of requests that will be made in parallel.

*   **from\_timestamp** (_Optional__\[__float__\]_ _\= None_) – If the timestamp is mentioned, will only export tasks that were labeled/updated since the given timestamp. Format - output from datetime.timestamp()

*   **with\_labels** (_bool = False_) – Get metadata of labels submitted in each stage.


Returns:

\>>> \[{
    "taskId": string,
    "currentStageName": string,
    "events": List\[Dict\]
}\]

Return type:

Iterator\[Dict\]

_abstract_ get\_active\_time(_\*_, _stage\_name_, _task\_id\=None_, _concurrency\=100_)[#](#redbrick.common.export.Export.get_active_time "Link to this definition")

Get active time spent on tasks for labeling/reviewing.

Parameters:

*   **stage\_name** (_str_) – Stage for which to return the time info.

*   **task\_id** (_Optional__\[__str__\]_ _\= None_) – If set, will return info for the given task in the given stage.

*   **concurrency** (_int = 100_) – Request batch size.


Returns:

\>>> \[{
    "orgId": string,
    "projectId": string,
    "stageName": string,
    "taskId": string,
    "completedBy": string,
    "timeSpent": number,  # In milliseconds
    "completedAt": datetime,
    "cycle": number  # Task cycle
}\]

Return type:

Iterator\[Dict\]

#### Upload[#](#upload "Link to this heading")

_class_ redbrick.common.upload.Upload[#](#redbrick.common.upload.Upload "Link to this definition")

Bases: `ABC`

Primary interface for uploading to a project.

\>>> project \= redbrick.get\_project(api\_key\="", org\_id\="", project\_id\="")
\>>> project.upload

_abstract_ create\_datapoints(_storage\_id_, _points_, _\*_, _is\_ground\_truth\=False_, _segmentation\_mapping\=None_, _rt\_struct\=False_, _mhd\=False_, _label\_storage\_id\=None_, _label\_validate\=False_, _prune\_segmentations\=False_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.create_datapoints "Link to this definition")

Create datapoints in project.

Upload data, and optionally annotations, to your project. Please visit [our documentation](https://sdk.redbrickai.com/formats/index.html#import) to understand the format for `points`.

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
points \= \[
    {
        "name": "...",
        "series": \[
            {
                "items": "...",

                \# These fields are needed for importing segmentations.
                "segmentations": "...",
                "segmentMap": {...}
            }
        \]
    }
\]
project.upload.create\_datapoints(storage\_id, points)

Parameters:

*   **storage\_id** (_str_) – Your RedBrick AI external storage\_id. This can be found under the Storage Tab on the RedBrick AI platform. To directly upload images to rbai, use redbrick.StorageMethod.REDBRICK.

*   **points** (List\[[`InputTask`](index.html#redbrick.types.task.InputTask "redbrick.types.task.InputTask")\]) – Please see the RedBrick AI reference documentation for overview of the format. [https://sdk.redbrickai.com/formats/index.html#import](https://sdk.redbrickai.com/formats/index.html#import). All the fields with annotation information are optional.

*   **is\_ground\_truth** (_bool = False_) – If labels are provided in `points`, and this parameters is set to true, the labels will be added to the Ground Truth stage.

*   **segmentation\_mapping** (_Optional__\[__Dict__\]_ _\= None_) – Optional mapping of semantic\_mask segmentation class ids and RedBrick categories.

*   **rt\_struct** (_bool = False_) – Upload segmentations from DICOM RT-Struct files.

*   **mhd** (_bool = False_) – Upload segmentations from MHD files.

*   **label\_storage\_id** (_Optional__\[__str__\]_ _\= None_) – Optional label storage id to reference nifti segmentations. Defaults to items storage\_id if not specified.

*   **label\_validate** (_bool = False_) – Validate label nifti instances and segment map.

*   **prune\_segmentations** (_bool = False_) – Prune segmentations that are not part of the series.

*   **concurrency** (_int = 50_) –


Returns:

List of task objects with key response if successful, else error

Return type:

List\[Dict\]

Note

1\. If doing direct upload, please use `redbrick.StorageMethod.REDBRICK` as the storage id. Your items path must be a valid path to a locally stored image.

2\. When doing direct upload i.e. `redbrick.StorageMethod.REDBRICK`, if you didn’t specify a “name” field in your datapoints object, we will assign the “items” path to it.

_abstract_ delete\_tasks(_task\_ids_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.delete_tasks "Link to this definition")

Delete project tasks based on task ids.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
\>>> project.upload.delete\_tasks(\[...\])

Parameters:

*   **task\_ids** (_List__\[__str__\]_) – List of task ids to delete.

*   **concurrency** (_int = 50_) – The number of tasks to delete at a time. We recommend keeping this <= 50.


Returns:

True if successful, else False.

Return type:

bool

_abstract_ delete\_tasks\_by\_name(_task\_names_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.delete_tasks_by_name "Link to this definition")

Delete project tasks based on task names.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
\>>> project.upload.delete\_tasks\_by\_name(\[...\])

Parameters:

*   **task\_names** (_List__\[__str__\]_) – List of task names to delete.

*   **concurrency** (_int = 50_) – The number of tasks to delete at a time. We recommend keeping this <= 50.


Returns:

True if successful, else False.

Return type:

bool

_abstract_ update\_task\_items(_storage\_id_, _points_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.update_task_items "Link to this definition")

Update task items, meta data, heat maps, transforms, etc. for the mentioned task ids.

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
points \= \[
    {
        "taskId": "...",
        "series": \[
            {
                "items": "...",
            }
        \]
    }
\]
project.upload.update\_task\_items(storage\_id, points)

Parameters:

*   **storage\_id** (_str_) – Your RedBrick AI external storage\_id. This can be found under the Storage Tab on the RedBrick AI platform. To directly upload images to rbai, use redbrick.StorageMethod.REDBRICK.

*   **points** (List\[[`InputTask`](index.html#redbrick.types.task.InputTask "redbrick.types.task.InputTask")\]) – List of objects with taskId and series, where series contains a list of items paths to be updated for the task.

*   **concurrency** (_int = 50_) –


Returns:

List of task objects with key response if successful, else error

Return type:

List\[Dict\]

Note

1\. If doing direct upload, please use `redbrick.StorageMethod.REDBRICK` as the storage id. Your items path must be a valid path to a locally stored image.

_abstract_ import\_tasks\_from\_workspace(_source\_project\_id_, _task\_ids_, _with\_labels\=False_)[#](#redbrick.common.upload.Upload.import_tasks_from_workspace "Link to this definition")

Import tasks from another project in the same workspace.

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
project.upload.import\_tasks\_from\_workspace(source\_project\_id, task\_ids)

Parameters:

*   **source\_project\_id** (_str_) – The source project id from which tasks are to be imported.

*   **task\_ids** (_List__\[__str__\]_) – List of task ids to be imported.

*   **with\_labels** (_bool = False_) – If True, the labels will also be imported.


Return type:

None

_abstract_ update\_tasks\_priority(_tasks_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.update_tasks_priority "Link to this definition")

Update tasks’ priorities. Used to determine how the tasks get assigned to annotators/reviewers in auto-assignment.

Parameters:

*   **tasks** (_List__\[__Dict__\]_) – List of taskIds and their priorities. - \[{“taskId”: str, “priority”: float(\[0, 1\]), “user”?: str}\]

*   **concurrency** (_int = 50_) – The number of tasks to update at a time. We recommend keeping this <= 50.


Return type:

`None`

_abstract_ update\_tasks\_labels(_tasks_, _\*_, _rt\_struct\=False_, _mhd\=False_, _label\_storage\_id\='22222222-2222-2222-2222-222222222222'_, _label\_validate\=False_, _prune\_segmentations\=False_, _concurrency\=50_, _finalize\=False_, _time\_spent\_ms\=None_, _extra\_data\=None_)[#](#redbrick.common.upload.Upload.update_tasks_labels "Link to this definition")

Update tasks labels at any point in project pipeline.

project \= redbrick.get\_project(...)
tasks \= \[
    {
        "taskId": "...",
        "series": \[{...}\]
    },
\]

\# Overwrite labels in tasks
project.upload.update\_tasks\_labels(tasks)

Parameters:

*   **points** (List\[[`OutputTask`](index.html#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")\]) – Please see the RedBrick AI reference documentation for overview of the format. [https://sdk.redbrickai.com/formats/index.html#export](https://sdk.redbrickai.com/formats/index.html#export). All the fields with annotation information are optional.

*   **rt\_struct** (_bool = False_) – Upload segmentations from DICOM RT-Struct files.

*   **mhd** (_bool = False_) – Upload segmentations from MHD files.

*   **label\_storage\_id** (_Optional__\[__str__\]_ _\= None_) – Optional label storage id to reference nifti segmentations. Defaults to project annnotation storage\_id if not specified.

*   **label\_validate** (_bool = False_) – Validate label nifti instances and segment map.

*   **prune\_segmentations** (_bool = False_) – Prune segmentations that are not part of the series.

*   **concurrency** (_int = 50_) –

*   **finalize** (_bool = False_) – Submit the task in current stage.

*   **time\_spent\_ms** (_Optional__\[__int__\]_ _\= None_) – Time spent on the task in milliseconds.

*   **extra\_data** (_Optional__\[__Dict__\]_ _\= None_) – Extra data to be stored along with the task.


Return type:

`None`

_abstract_ send\_tasks\_to\_stage(_task\_ids_, _stage\_name_, _concurrency\=50_)[#](#redbrick.common.upload.Upload.send_tasks_to_stage "Link to this definition")

Send tasks to different stage.

Parameters:

*   **task\_ids** (_List__\[__str__\]_) – List of tasks to move.

*   **stage\_name** (_str_) – The stage to which you want to move the tasks. Use “END” to move tasks to ground truth.

*   **concurrency** (_int = 50_) – Batch size per request.


Return type:

`None`

#### Labeling[#](#labeling "Link to this heading")

_class_ redbrick.common.labeling.Labeling[#](#redbrick.common.labeling.Labeling "Link to this definition")

Bases: `ABC`

Perform programmatic labeling and review tasks.

The Labeling class allows you to programmatically submit tasks. This can be useful for times when you want to make bulk actions e.g accepting several tasks, or make automated actions like using automated methods for review.

Information

The Labeling module provides several methods to query tasks and assign tasks to different users. Refer to this section for guidance on when to use each method:

*   [`assign_tasks`](#redbrick.common.labeling.Labeling.assign_tasks "redbrick.common.labeling.Labeling.assign_tasks"). Use this method when you already have the `task_ids` you want to assign to a particular user. If you don’t have the `task_ids`, you can query the tasks using [`list_tasks`](#redbrick.common.export.Export.list_tasks "redbrick.common.export.Export.list_tasks").


_abstract_ put\_tasks(_stage\_name_, _tasks_, _\*_, _finalize\=True_, _existing\_labels\=False_, _rt\_struct\=False_, _mhd\=False_, _review\_result\=None_, _label\_storage\_id\='22222222-2222-2222-2222-222222222222'_, _label\_validate\=False_, _prune\_segmentations\=False_, _concurrency\=50_)[#](#redbrick.common.labeling.Labeling.put_tasks "Link to this definition")

Put tasks with new labels or a review result.

Use this method to programmatically submit tasks with labels in Label stage, or to programmatically accept/reject/correct tasks in a Review stage. If you don’t already have a list of `task_id`, you can use [`list_tasks`](#redbrick.common.export.Export.list_tasks "redbrick.common.export.Export.list_tasks") to get a filtered list of tasks in your project, that you want to work upon.

Label

project \= redbrick.get\_project(...)
tasks \= \[
    {
        "taskId": "...",
        "series": \[{...}\]
    },
\]

\# Submit tasks with new labels
project.labeling.put\_tasks("Label", tasks)

\# Save tasks with new labels, without submitting
project.labeling.put\_tasks("Label", tasks, finalize\=False)

\# Submit tasks with existing labels
project.labeling.put\_tasks("Label", \[{"taskId":"..."}\], existing\_labels\=True)

Review

project \= redbrick.get\_project(...)

\# Set review\_result to True if you want to accept the tasks
project.review.put\_tasks("Review\_1", \[{taskId: "..."}\], review\_result\=True)

\# Set review\_result to False if you want to reject the tasks
project.review.put\_tasks("Review\_1", \[{taskId: "..."}\], review\_result\=False)

\# Add labels if you want to accept the tasks with correction
project.review.put\_tasks("Review\_1", \[{taskId: "...", series: \[{...}\]}\])

Parameters:

*   **stage\_name** (_str_) – The stage to which you want to submit the tasks. This must be the same stage as which you called get\_tasks on.

*   **tasks** (List\[[`OutputTask`](index.html#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")\]) – Tasks with new labels or review result.

*   **finalize** (_bool = True_) – Finalize the task. If you want to save the task without submitting, set this to False.

*   **existing\_labels** (_bool = False_) – If True, the tasks will be submitted with their existing labels. Applies only to Label stage.

*   **rt\_struct** (_bool = False_) – Upload segmentations from DICOM RT-Struct files.

*   **mhd** (_bool = False_) – Upload segmentations from MHD files.

*   **review\_result** (_Optional__\[__bool__\]_ _\= None_) – Accepts or rejects the task based on the boolean value. Applies only to Review stage.

*   **label\_storage\_id** (_Optional__\[__str__\]_ _\= None_) – Optional label storage id to reference external nifti segmentations. Defaults to project settings’ annotation storage\_id if not specified.

*   **label\_validate** (_bool = False_) – Validate label nifti instances and segment map.

*   **prune\_segmentations** (_bool = False_) – Prune segmentations that are not part of the series.

*   **concurrency** (_int = 50_) –


Returns:

A list of tasks that failed.

Return type:

List\[[`OutputTask`](index.html#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")\]

_abstract_ assign\_tasks(_task\_ids_, _\*_, _email\=None_, _emails\=None_, _refresh\=True_)[#](#redbrick.common.labeling.Labeling.assign_tasks "Link to this definition")

Assign tasks to specified email or current API key.

Unassigns all users from the task if neither of the `email` or `current_user` are set.

\>>> project \= redbrick.get\_project(org\_id, project\_id, api\_key)
\>>> project.labeling.assign\_tasks(\[task\_id\], email\=email)

Parameters:

*   **task\_ids** (_List__\[__str__\]_) – List of unique `task_id` of the tasks you want to assign.

*   **email** (_Optional__\[__str__\]_ _\= None_) – The email of the user you want to assign this task to. Make sure the user has adequate permissions to be assigned this task in the project.

*   **emails** (_Optional__\[__List__\[__str__\]__\]_ _\= None_) – Used for projects with Consensus activated. The emails of the users you want to assign this task to. Make sure the users have adequate permissions to be assigned this task in the project.

*   **refresh** (_bool = True_) – Used for projects with Consensus activated. If True, will overwrite the assignment to the current users.


Returns:

List of affected tasks.

\>>> \[{"taskId", "name", "stageName"}\]

Return type:

List\[Dict\]

_abstract_ move\_tasks\_to\_start(_task\_ids_)[#](#redbrick.common.labeling.Labeling.move_tasks_to_start "Link to this definition")

Move groundtruth tasks back to start.

Return type:

`None`

#### Settings[#](#settings "Link to this heading")

_class_ redbrick.common.settings.Settings[#](#redbrick.common.settings.Settings "Link to this definition")

Bases: `ABC`

Abstract interface to Settings module.

_abstract property_ label\_validation_: LabelValidation_[#](#redbrick.common.settings.Settings.label_validation "Link to this definition")

Label Validation.

Use custom label validation to prevent annotation errors in real-time. Please visit [label validation](https://docs.redbrickai.com/projects/custom-label-validation) for more info.

Format: {“enabled”: bool, “enforce”: bool, “script”: str}

Get

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
label\_validation \= project.settings.label\_validation

Set

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
project.settings.label\_validation \= label\_validation

_abstract property_ hanging\_protocol_: HangingProtocol_[#](#redbrick.common.settings.Settings.hanging_protocol "Link to this definition")

Hanging Protocol.

Use hanging protocol to define the visual layout of tool. Please visit [hanging protocol](https://docs.redbrickai.com/annotation/layout-and-multiple-volumes/custom-hanging-protocol) for more info.

Format: {“enabled”: bool, “script”: str}

Get

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
hanging\_protocol \= project.settings.hanging\_protocol

Set

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
project.settings.hanging\_protocol \= hanging\_protocol

_abstract property_ webhook_: Webhook_[#](#redbrick.common.settings.Settings.webhook "Link to this definition")

Project webhook.

Use webhooks to receive custom events like tasks entering stages, and many more.

Format: {“enabled”: bool, “url”: str}

Get

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
webhook \= project.settings.webhook

Set

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
project.settings.webhook \= webhook

_abstract_ toggle\_reference\_standard\_task(_task\_id_, _enable_)[#](#redbrick.common.settings.Settings.toggle_reference_standard_task "Link to this definition")

Toggle reference standard task.

Return type:

`None`

_abstract property_ task\_duplication_: int | None_[#](#redbrick.common.settings.Settings.task_duplication "Link to this definition")

Sibling task count.

Use task duplication to create multiple tasks for a single uploaded datapoint. Please visit [task duplication](https://docs.redbrickai.com/projects/multiple-labeling/task-duplication) for more info.

Format: Optional\[int\]

Get

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
count \= project.settings.task\_duplication

Set

project \= redbrick.get\_project(org\_id, project\_id, api\_key, url)
project.settings.task\_duplication \= count

#### Workforce[#](#workforce "Link to this heading")

_class_ redbrick.common.member.Workforce[#](#redbrick.common.member.Workforce "Link to this definition")

Bases: `ABC`

Abstract interface to Workforce module.

_abstract_ get\_member(_member\_id_)[#](#redbrick.common.member.Workforce.get_member "Link to this definition")

Get a project member.

project \= redbrick.get\_project(org\_id, project\_id, api\_key)
member \= project.workforce.get\_member(member\_id)

Parameters:

**member\_id** (_str_) – Unique member userId or email.

Return type:

[ProjectMember](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")

_abstract_ list\_members()[#](#redbrick.common.member.Workforce.list_members "Link to this definition")

Get a list of all project members.

project \= redbrick.get\_project(org\_id, project\_id, api\_key)
members \= project.workforce.list\_members()

Return type:

List\[[ProjectMember](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")\]

_abstract_ add\_members(_members_)[#](#redbrick.common.member.Workforce.add_members "Link to this definition")

Add project members.

project \= redbrick.get\_project(org\_id, project\_id, api\_key)
member \= project.workforce.add\_members(\[{"member\_id": "...", "role": "...", "stages": \["..."\]}, ...\])

Parameters:

**members** (_List__\[_[_ProjectMember_](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")_\]_) – List of members to add.

Returns:

List of added project members.

Return type:

List\[[ProjectMember](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")\]

_abstract_ update\_members(_members_)[#](#redbrick.common.member.Workforce.update_members "Link to this definition")

Update project members.

project \= redbrick.get\_project(org\_id, project\_id, api\_key)
member \= project.workforce.update\_members(\[{"member\_id": "...", "role": "...", "stages": \["..."\]}, ...\])

Parameters:

**members** (_List__\[_[_ProjectMember_](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")_\]_) – List of members to update.

Returns:

List of updated project members.

Return type:

List\[[ProjectMember](index.html#redbrick.ProjectMember "redbrick.common.member.ProjectMember")\]

_abstract_ remove\_members(_member\_ids_)[#](#redbrick.common.member.Workforce.remove_members "Link to this definition")

Remove project members.

project \= redbrick.get\_project(org\_id, project\_id, api\_key)
member \= project.workforce.remove\_members(\[...\])

Parameters:

**member\_ids** (_List__\[__str__\]_) – List of member ids (user\_id/email) to remove from the project.

Return type:

`None`

Command Line Interface[#](#command-line-interface "Link to this heading")
-------------------------------------------------------------------------

The RedBrick CLI offers a simple interface to quickly import and export your images & annotations, and perform other high-level actions.

See the [Command Line Interface](index.html#cli) documentation for more information.

[](index.html#cli)

### Command Line Interface[#](#command-line-interface "Link to this heading")

The RedBrick CLI offers a simple interface to quickly import and export your images & annotations, and perform other high-level actions.

usage: redbrick \[\-h\] \[\-v\] \[\--completion {bash,zsh,tcsh}\]
                {config,init,clone,info,export,upload,report} ...

#### Named Arguments[#](#named-arguments "Link to this heading")

\-v, --version

show program’s version number and exit

\--completion

Possible choices: bash, zsh, tcsh

print shell completion script

#### Commands[#](#commands "Link to this heading")

command

Possible choices: config, init, clone, info, export, upload, report

#### Sub-commands[#](#Sub-commands "Link to this heading")

##### config[#](#config "Link to this heading")

Setup the credentials for your CLI.

redbrick config \[\-h\] \[\--org ORG\] \[\--key KEY\] \[\--url URL\] \[\--profile PROFILE\]
                \[\--force\]
                {list,set,add,remove,clear,verify} ...

###### Positional Arguments[#](#positional-arguments "Link to this heading")

sub\_command

Possible choices: list, set, add, remove, clear, verify

###### Named Arguments[#](#named-arguments_repeat1 "Link to this heading")

\--org, -o

Org ID

\--key, -k

API Key

\--url, -u

Endpoint URL, should default to https://api.redbrickai.com.

\--profile, -p

Profile name

\--force, -f

Force create new credentials

Default: False

###### Sub-commands[#](#Sub-commands_repeat1 "Link to this heading")

###### list[#](#list "Link to this heading")

List all credential profiles

redbrick config list \[\-h\]

###### set[#](#set "Link to this heading")

Set your default credentials profile

redbrick config set \[\-h\] \[profile\]

###### Positional Arguments[#](#positional-arguments_repeat1 "Link to this heading")

profile

Profile name

###### add[#](#add "Link to this heading")

Add a new profile

redbrick config add \[\-h\] \[\--org ORG\] \[\--key KEY\] \[\--url URL\]
                    \[\--profile PROFILE\]

###### Named Arguments[#](#named-arguments_repeat2 "Link to this heading")

\--org, -o

Org ID

\--key, -k

Add your API Key.

\--url, -u

Endpoint URL, should default to https://api.redbrickai.com.

\--profile, -p

Define a name for your authentication profile.

###### remove[#](#remove "Link to this heading")

Remove a profile

redbrick config remove \[\-h\] \[profile\]

###### Positional Arguments[#](#positional-arguments_repeat2 "Link to this heading")

profile

Profile name

###### clear[#](#clear "Link to this heading")

Clear all credentials

redbrick config clear \[\-h\]

###### verify[#](#verify "Link to this heading")

Verify a profile

redbrick config verify \[\-h\] \[profile\]

###### Positional Arguments[#](#positional-arguments_repeat3 "Link to this heading")

profile

Profile name

##### init[#](#init "Link to this heading")

Create a new project. We recommend creating a new directory and naming it after your project, initializing your project within the new directory.

$ mkdir new-project
$ cd new-project
$ redbrick init

redbrick init \[\-h\] \[\--name NAME\] \[\--taxonomy TAXONOMY\] \[\--reviews REVIEWS\]
              \[\--workspace WORKSPACE\] \[\--sibling\-tasks SIBLING\_TASKS\]
              \[path\]

###### Positional Arguments[#](#positional-arguments_repeat4 "Link to this heading")

path

Local path of the empty project directory

Default: “.”

###### Named Arguments[#](#named-arguments_repeat3 "Link to this heading")

\--name, -n

Project name

\--taxonomy, -t

Taxonomy name

\--reviews, -r

Number of review stages

\--workspace, -w

The workspace that you want to add this project to

\--sibling-tasks

Number of tasks created for each uploaded datapoint

##### clone[#](#clone "Link to this heading")

The project will be cloned to a local directory named after your `project name`.

redbrick clone \[\-h\] \[project\] \[path\]

###### Positional Arguments[#](#positional-arguments_repeat5 "Link to this heading")

project

Project ID or Name

path

Local path of the empty project directory

##### info[#](#info "Link to this heading")

Get a project’s information

redbrick info \[\-h\] \[\--get {labelstorage}\] \[\--set {labelstorage}\] \[path\]

###### Positional Arguments[#](#positional-arguments_repeat6 "Link to this heading")

path

Path of project (Default: current directory)

Default: “.”

###### Named Arguments[#](#named-arguments_repeat4 "Link to this heading")

\--get, -g

Possible choices: labelstorage

Get a project’s setting information

\--set, -s

Possible choices: labelstorage

Set a project setting

##### export[#](#export "Link to this heading")

Export data for a project

redbrick export \[\-h\] \[\--with\-files\] \[\--dicom\-to\-nifti\] \[\--old\-format\]
                \[\--without\-masks\] \[\--semantic\] \[\--binary\-mask\] \[\--single\-mask\]
                \[\--no\-consensus\] \[\--png\] \[\--rt\-struct\] \[\--mhd\] \[\--clear\-cache\]
                \[\--concurrency CONCURRENCY\] \[\--stage STAGE\]
                \[\--destination DESTINATION\]
                \[type\]

###### Positional Arguments[#](#positional-arguments_repeat7 "Link to this heading")

type

Export type: (latest \[default\], groundtruth, )

Default: “latest”

###### Named Arguments[#](#named-arguments_repeat5 "Link to this heading")

\--with-files

Export with files (e.g. images/video frames)

Default: False

\--dicom-to-nifti

Convert DICOM images to NIfTI. Applicable when `--with-files` is set.

Default: False

\--old-format

Whether to export tasks in old format. (Default: False)

Default: False

\--without-masks

Exports only tasks JSON without downloading any segmentation masks. Note: This is not recommended for tasks with overlapping labels.

Default: False

\--semantic

Whether to export all segmentations as semantic\_mask. This will create one segmentation file per class. If this is set to True and a task has multiple instances per class, then attributes belonging to each instance will not be exported.

Default: False

\--binary-mask

Whether to export all segmentations as binary masks. This will create one segmentation file per instance.

Default: False

\--single-mask

Whether to export all segmentations in a single file. Binary mask will be considered if both binary\_mask and single\_mask are set.

Default: False

\--no-consensus

Whether to export tasks without consensus info. If None, will default to export with consensus info, if it is enabled for the given project.

Default: False

\--png

Export labels as PNG masks

Default: False

\--rt-struct

Export labels as DICOM RT-Struct. (Only for DICOM images)

Default: False

\--mhd

Export segmentation masks in MHD format.

Default: False

\--clear-cache

Clear local cache

Default: False

\--concurrency, -c

Concurrency value (Default: 10)

Default: 10

\--stage, -s

Export tasks that are currently in the given stage. Applicable only with `redbrick export` and `redbrick export latest`

\--destination, -d

Destination directory (Default: current directory)

Default: “.”

##### upload[#](#upload "Link to this heading")

Upload files to a project

redbrick upload \[\-h\] \[\--as\-frames\]
                \[\--type \[{DICOM3D,NIFTI3D,NRRD3D,IMAGE2D,VIDEO,VIDEOFRAMES}\]\]
                \[\--as\-study\] \[\--json\] \[\--segment\-map SEGMENT\_MAP\]
                \[\--storage STORAGE\] \[\--label\-storage LABEL\_STORAGE\]
                \[\--ground\-truth\] \[\--label\-validate\] \[\--prune\-segmentations\]
                \[\--rt\-struct\] \[\--mhd\] \[\--clear\-cache\]
                \[\--concurrency CONCURRENCY\]
                directory

###### Positional Arguments[#](#positional-arguments_repeat8 "Link to this heading")

directory

The directory containing files to upload to the project

###### Named Arguments[#](#named-arguments_repeat6 "Link to this heading")

\--as-frames

Upload video from image frames

Default: False

\--type, -t

Possible choices: DICOM3D, NIFTI3D, NRRD3D, IMAGE2D, VIDEO, VIDEOFRAMES

Import file type \[’`DICOM3D`’, ‘`NIFTI3D`’, ‘`NRRD3D`’, ‘`IMAGE2D`’, ‘`VIDEO`’, ‘`VIDEOFRAMES`’\]

Please refer to [our documentation](https://docs.redbrickai.com/importing-data/direct-data-upload), to understand the required folder structure and supported file types.

Default: “DICOM3D”

\--as-study

Group files by study

Default: False

\--json

Upload json files with list of task objects

Default: False

\--segment-map, -m

Segmentation mapping file path

\--storage, -s

Storage method: (redbrick \[default\], public, )

Default: “redbrick”

\--label-storage

Label Storage method: (same as items storage `--storage` \[default\], redbrick, public, )

\--ground-truth

Upload tasks directly to ground truth.

Default: False

\--label-validate

Validate NIfTI label instances and segmentMap. By default, the uploaded NIfTI files are not validated during upload, which can result in invalid files being uploaded. Using this argument validates the files before upload, but may increase the upload time.

Default: False

\--prune-segmentations

Prune segmentations that are not part of the series.

Default: False

\--rt-struct

Upload segmentations from DICOM RT-Struct files.

Default: False

\--mhd

Upload segmentations from MHD files.

Default: False

\--clear-cache

Clear local cache

Default: False

\--concurrency, -c

Concurrency value (Default: 10)

Default: 10

##### report[#](#report "Link to this heading")

Generate an audit report for a project. Exports a JSON file containing all actions & events associated with every task, including:

*   Who annotated the task

*   Who uploaded the data

*   Who reviewed the task

*   and more.


redbrick report \[\-h\] \[\--concurrency CONCURRENCY\] \[type\]

###### Positional Arguments[#](#positional-arguments_repeat9 "Link to this heading")

type

Export type: (all \[default\], groundtruth)

Default: “all”

###### Named Arguments[#](#named-arguments_repeat7 "Link to this heading")

\--concurrency, -c

Concurrency value (Default: 10)

Default: 10

Formats[#](#formats "Link to this heading")
-------------------------------------------

Formats for importing & exporting data, and interfacing with various entities on RedBrick AI.

See the [Formats](index.html#formats) documentation for more information.

[](index.html#formats)

### Formats[#](#formats "Link to this heading")

This section will document the structure used for importing and exporting data from RedBrick AI.

#### Import[#](#import "Link to this heading")

The RedBrick AI SDK uses a list of [`redbrick.types.task.InputTask`](#redbrick.types.task.InputTask "redbrick.types.task.InputTask") objects for importing data. To import data through the CLI or SDK, create a JSON file that follows the same format.

_class_ redbrick.types.task.InputTask[#](#redbrick.types.task.InputTask "Link to this definition")

Represents a single task in RedBrick AI, which is a unit of labeling work. This user-defined object can contain one or more series of mixed modalities.

name_: `str`_[#](#redbrick.types.task.InputTask.name "Link to this definition")

A unique user defined string for quickly identifying and searching tasks.

series_: `List`\[[`Series`](#redbrick.types.task.Series "redbrick.types.task.Series")\]_[#](#redbrick.types.task.InputTask.series "Link to this definition")

Add more than one series per task by adding multiple entries to series list.

classification_: [`Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification")_[#](#redbrick.types.task.InputTask.classification "Link to this definition")

For importing Study level classifications [`redbrick.types.task.Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification").

priority_: `float`_[#](#redbrick.types.task.InputTask.priority "Link to this definition")

priority must between \[0, 1\]. Tasks will be ordered in descending order of priority.

metaData_: `Dict`\[`str`, `str`\]_[#](#redbrick.types.task.InputTask.metaData "Link to this definition")

Used for displaying Task level meta-data within the annotation viewer.

preAssign_: `Dict`\[`str`, `Union`\[`str`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.InputTask.preAssign "Link to this definition")

Specify user email(s) to automatically assign this task to them.

_class_ redbrick.types.task.Series[#](#redbrick.types.task.Series "Link to this definition")

A single series represents a single volume, image, or video. A [`redbrick.types.task.InputTask`](#redbrick.types.task.InputTask "redbrick.types.task.InputTask") can have multiple series.

items_: `Union`\[`str`, `List`\[`str`\]\]_ _\= <method 'items' of 'dict' objects>_[#](#redbrick.types.task.Series.items "Link to this definition")

Path(s) to the image instances of this series.

DICOM 3D

\# DICOM instances don't need to be in order.
items \= \["instance001.dcm", "instance000.dcm", "instance003.dcm\]

DICOM 2D

items \= "path/to/instance.dcm"

NIfTI

items \= "path/to/nifti.nii

Video frames

\# Frames need to be in correct order.
items \= \["fram001.png", "frame002.png", "frame003.png"\]

name_: `str`_[#](#redbrick.types.task.Series.name "Link to this definition")

Unique identifier for the series that will be displayed on the annotation viewport.

metaData_: `Dict`\[`str`, `str`\]_[#](#redbrick.types.task.Series.metaData "Link to this definition")

Series level meta-data will be displayed on the viewport.

segmentations_: `Union`\[`str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Series.segmentations "Link to this definition")

Path to your NIfTI segmentation files for uploading annotations.

Read our guide on [importing annotation](https://docs.redbrickai.com/python-sdk/importing-annotations-guide) to learn more.

Single

If your series has a single segmentation file.

items \= "path/to/segmentation.nii"

Multiple

If your series has multiple segmentation files for different instances.

items \= \["path/to/instance01.nii", "path/to/instance02.nii"\]

segmentMap_: `Dict`\[`Union`\[`str`, `int`\], `Union`\[`str`, `int`, `List`\[`str`\], [`CommonLabelProps`](index.html#redbrick.types.task.CommonLabelProps "redbrick.types.task.CommonLabelProps")\]\]_[#](#redbrick.types.task.Series.segmentMap "Link to this definition")

A mapping between your segmentation file instance values (values inside your NIfTI files) and your RedBrick AI taxonomy categories.

Read our guide on [importing annotation](https://docs.redbrickai.com/python-sdk/importing-annotations-guide) to learn more.

Shorthand

“1” and “2” are values present the NIfTI files defined by [`redbrick.types.task.Series.segmentations`](#redbrick.types.task.Series.segmentations "redbrick.types.task.Series.segmentations"). Those values will be mapped to your RedBrick AI taxonomy categories “category a” and “category b”.

segmentMap \= {
    "1": "category a",
    "2": "category b"
}

Full

“1” and “2” are values present the NIfTI files defined by [`redbrick.types.task.Series.segmentations`](#redbrick.types.task.Series.segmentations "redbrick.types.task.Series.segmentations"). Those values will be mapped to your RedBrick AI taxonomy categories “category a” and “category b”.

`Attributes`: [`redbrick.types.task.Attributes`](index.html#redbrick.types.task.Attributes "redbrick.types.task.Attributes")

segmentMap \= {
    "1": {
        "category": "category a",
        "mask": "path/to/segmentation.nii"
        "attributes": Attributes
    },
    "2": {
        "category": "category b",
        "mask": "path/to/segmentation.nii"
        "attributes": Attributes
    }
}

heatMaps_: `List`\[[`HeatMap`](#redbrick.types.task.HeatMap "redbrick.types.task.HeatMap")\]_[#](#redbrick.types.task.Series.heatMaps "Link to this definition")

Heatmaps for the series.

transforms_: `List`\[[`Transform`](#redbrick.types.task.Transform "redbrick.types.task.Transform")\]_[#](#redbrick.types.task.Series.transforms "Link to this definition")

Transforms for the series.

centerline_: `List`\[[`Centerline`](#redbrick.types.task.Centerline "redbrick.types.task.Centerline")\]_[#](#redbrick.types.task.Series.centerline "Link to this definition")

Centerline info for the series.

binaryMask_: `bool`_[#](#redbrick.types.task.Series.binaryMask "Link to this definition")

Treats all files in [`redbrick.types.task.Series.segmentations`](#redbrick.types.task.Series.segmentations "redbrick.types.task.Series.segmentations") as binary masks. That is, any non-zero value will be treated as a single instance.

pngMask_: `bool`_[#](#redbrick.types.task.Series.pngMask "Link to this definition")

Set to true if uploading PNG masks.

landmarks_: `List`\[[`Landmark`](index.html#redbrick.types.task.Landmark "redbrick.types.task.Landmark")\]_[#](#redbrick.types.task.Series.landmarks "Link to this definition")

2D landmarks for 2D data.

landmarks3d_: `List`\[[`Landmark3D`](index.html#redbrick.types.task.Landmark3D "redbrick.types.task.Landmark3D")\]_[#](#redbrick.types.task.Series.landmarks3d "Link to this definition")

3D landmarks for 3D data.

measurements_: `List`\[`Union`\[[`MeasureLength`](index.html#redbrick.types.task.MeasureLength "redbrick.types.task.MeasureLength"), [`MeasureAngle`](index.html#redbrick.types.task.MeasureAngle "redbrick.types.task.MeasureAngle")\]\]_[#](#redbrick.types.task.Series.measurements "Link to this definition")

Length or angle measurements. Not supported in videos.

ellipses_: `List`\[[`Ellipse`](index.html#redbrick.types.task.Ellipse "redbrick.types.task.Ellipse")\]_[#](#redbrick.types.task.Series.ellipses "Link to this definition")

Ellipse annotation. Not supported in Videos.

boundingBoxes_: `List`\[[`BoundingBox`](index.html#redbrick.types.task.BoundingBox "redbrick.types.task.BoundingBox")\]_[#](#redbrick.types.task.Series.boundingBoxes "Link to this definition")

2D bounding box for 2D images, or slice by slice annotation in 3D images.

cuboids_: `List`\[[`Cuboid`](index.html#redbrick.types.task.Cuboid "redbrick.types.task.Cuboid")\]_[#](#redbrick.types.task.Series.cuboids "Link to this definition")

3D bounding boxes for 3D images.

polygons_: `List`\[[`Polygon`](index.html#redbrick.types.task.Polygon "redbrick.types.task.Polygon")\]_[#](#redbrick.types.task.Series.polygons "Link to this definition")

Closed polygons, not supported in 3D images.

polylines_: `List`\[[`Polyline`](index.html#redbrick.types.task.Polyline "redbrick.types.task.Polyline")\]_[#](#redbrick.types.task.Series.polylines "Link to this definition")

Open polylines, not supported in 3D images.

classifications_: `List`\[[`Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification")\]_[#](#redbrick.types.task.Series.classifications "Link to this definition")

Series level classifications.

instanceClassifications_: `List`\[[`InstanceClassification`](index.html#redbrick.types.task.InstanceClassification "redbrick.types.task.InstanceClassification")\]_[#](#redbrick.types.task.Series.instanceClassifications "Link to this definition")

Instance level classifications for frame-by-frame (video) or slice-by-slice (volume) classifications.

_class_ redbrick.types.task.HeatMap[#](#redbrick.types.task.HeatMap "Link to this definition")

Heat map.

name_: `str`_[#](#redbrick.types.task.HeatMap.name "Link to this definition")

Name.

item_: `str`_[#](#redbrick.types.task.HeatMap.item "Link to this definition")

File path.

preset_: `str`_[#](#redbrick.types.task.HeatMap.preset "Link to this definition")

Preset.

dataRange_: `List`\[`float`\]_[#](#redbrick.types.task.HeatMap.dataRange "Link to this definition")

Data range.

opacityPoints_: `List`\[`float`\]_[#](#redbrick.types.task.HeatMap.opacityPoints "Link to this definition")

Opacity points.

opacityPoints3d_: `List`\[`float`\]_[#](#redbrick.types.task.HeatMap.opacityPoints3d "Link to this definition")

Opacity points 3D.

rgbPoints_: `List`\[`float`\]_[#](#redbrick.types.task.HeatMap.rgbPoints "Link to this definition")

RGB points.

_class_ redbrick.types.task.Transform[#](#redbrick.types.task.Transform "Link to this definition")

Transform.

transform_: `List`\[`List`\[`float`\]\]_[#](#redbrick.types.task.Transform.transform "Link to this definition")

Transformation matrix (4x4).

_class_ redbrick.types.task.Centerline[#](#redbrick.types.task.Centerline "Link to this definition")

Centerline info.

name_: `str`_[#](#redbrick.types.task.Centerline.name "Link to this definition")

Centerline name

centerline_: `Dict`_[#](#redbrick.types.task.Centerline.centerline "Link to this definition")

Centerline polydata

#### Export[#](#export "Link to this heading")

The RedBrick SDK will export a list of [`redbrick.types.task.OutputTask`](#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask") objects, along with NIfTI segmentation files if they exist, written to the disk. The CLI will export in the same format in a JSON file.

_class_ redbrick.types.task.OutputTask[#](#redbrick.types.task.OutputTask "Link to this definition")

Single task object on export.

taskId_: `str`_[#](#redbrick.types.task.OutputTask.taskId "Link to this definition")

System generated unique identifier for the task.

name_: `str`_[#](#redbrick.types.task.OutputTask.name "Link to this definition")

A unique user defined string for quickly identifying and searching tasks.

series_: `List`\[[`Series`](#redbrick.types.task.Series "redbrick.types.task.Series")\]_[#](#redbrick.types.task.OutputTask.series "Link to this definition")

List of series in the task [`redbrick.types.task.Series`](#redbrick.types.task.Series "redbrick.types.task.Series").

classification_: [`Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification")_[#](#redbrick.types.task.OutputTask.classification "Link to this definition")

Study level classifications [`redbrick.types.task.Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification").

priority_: `float`_[#](#redbrick.types.task.OutputTask.priority "Link to this definition")

Task priority in the range \[0, 1\].

metaData_: `Dict`\[`str`, `str`\]_[#](#redbrick.types.task.OutputTask.metaData "Link to this definition")

Task level meta-data within the annotation viewer.

currentStageName_: `str`_[#](#redbrick.types.task.OutputTask.currentStageName "Link to this definition")

Name of the stage in which this task currently is.

status_: [`TaskStates`](#redbrick.common.enums.TaskStates "redbrick.common.enums.TaskStates")_[#](#redbrick.types.task.OutputTask.status "Link to this definition")

Current status of the task in the workflow.

createdBy_: `str`_[#](#redbrick.types.task.OutputTask.createdBy "Link to this definition")

E-mail of the user who uploaded this task.

createdAt_: `str`_[#](#redbrick.types.task.OutputTask.createdAt "Link to this definition")

Timestamp of when this task was uploaded.

updatedBy_: `str`_[#](#redbrick.types.task.OutputTask.updatedBy "Link to this definition")

E-mail of the user who last edited this task.

updatedByUserId_: `str`_[#](#redbrick.types.task.OutputTask.updatedByUserId "Link to this definition")

System generated unique user ID of user who last edited this task.

updatedAt_: `str`_[#](#redbrick.types.task.OutputTask.updatedAt "Link to this definition")

Timestamp of when this task was last edited.

consensus_: `bool`_[#](#redbrick.types.task.OutputTask.consensus "Link to this definition")

If true, this task is a consensus task, i.e., it was labeled by more than one person.

consensusScore_: `float`_[#](#redbrick.types.task.OutputTask.consensusScore "Link to this definition")

Agreement score between annotators who labeled this task.

Read more about the score calculation [here](https://docs.redbrickai.com/projects/consensus-inter-annotator-agreement/agreement-calculation).

consensusTasks_: `List`\[[`OutputTask`](#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")\]_[#](#redbrick.types.task.OutputTask.consensusTasks "Link to this definition")

A list of all the results from consensus. One entry for each annotator.

scores_: `List`\[[`ConsensusScore`](#redbrick.types.task.ConsensusScore "redbrick.types.task.ConsensusScore")\]_[#](#redbrick.types.task.OutputTask.scores "Link to this definition")

Matrix of the agreement scores between the labelers.

superTruth_: [`OutputTask`](#redbrick.types.task.OutputTask "redbrick.types.task.OutputTask")_[#](#redbrick.types.task.OutputTask.superTruth "Link to this definition")

Supertruth version produced in consensus review stage.

datapointClassification_: [`Classification`](index.html#redbrick.types.task.Classification "redbrick.types.task.Classification")_[#](#redbrick.types.task.OutputTask.datapointClassification "Link to this definition")

Datapoint classification attributes.

_class_ redbrick.types.task.ConsensusScore[#](#redbrick.types.task.ConsensusScore "Link to this definition")

Consensus score for a pair of annotators for a consensus task.

secondaryUser_: `str`_[#](#redbrick.types.task.ConsensusScore.secondaryUser "Link to this definition")

User who is compared to primary user.

secondaryUserId_: `str`_[#](#redbrick.types.task.ConsensusScore.secondaryUserId "Link to this definition")

User id of user who is compared to primary user.

secondaryUserEmail_: `str`_[#](#redbrick.types.task.ConsensusScore.secondaryUserEmail "Link to this definition")

User email of user who is compared to the primary user.

score_: `float`_[#](#redbrick.types.task.ConsensusScore.score "Link to this definition")

Agreement score between the primary user and this secondary user.

_class_ redbrick.common.enums.TaskStates(_value_, _names\=None_, _\*_, _module\=None_, _qualname\=None_, _type\=None_, _start\=1_, _boundary\=None_)[#](#redbrick.common.enums.TaskStates "Link to this definition")

Task Status.

*   `UNASSIGNED` - The Task has not been assigned to a Project Admin or Member.

*   `ASSIGNED` - The Task has been assigned to a Project Admin or Member,

    but work has not begun on it.

*   `IN_PROGRESS` - The Task is currently being worked on by a Project Admin or Member.

*   `COMPLETED` - The Task has been completed successfully.

*   `PROBLEM` - A Project Admin or Member has raised an Issue regarding the Task,

    and work cannot continue until the Issue is resolved by a Project Admin.

*   `SKIPPED` - The Task has been skipped.

*   `STAGED` - The Task has been saved as a Draft.


##### Annotation type definitions[#](#annotation-type-definitions "Link to this heading")

This section covers definitions of all the annotation object types. The objects are the same for importing annotations, and exporting annotations.

[`Label Type`](index.html#redbrick.types.taxonomy.ObjectType.labelType "redbrick.types.taxonomy.ObjectType.labelType")

Label Definition

2D Image

3D Volume

Video

CLASSIFICATION (non objectType)

[`Classification`](#redbrick.types.task.Classification "redbrick.types.task.Classification")

SEGMENTATION

[`CommonLabelProps`](#redbrick.types.task.CommonLabelProps "redbrick.types.task.CommonLabelProps")

LENGTH

[`MeasureLength`](#redbrick.types.task.MeasureLength "redbrick.types.task.MeasureLength")

ANGLE

[`MeasureAngle`](#redbrick.types.task.MeasureAngle "redbrick.types.task.MeasureAngle")

POINT

[`Landmark`](#redbrick.types.task.Landmark "redbrick.types.task.Landmark")

[`Landmark3D`](#redbrick.types.task.Landmark3D "redbrick.types.task.Landmark3D")

POLYLINE

[`Polyline`](#redbrick.types.task.Polyline "redbrick.types.task.Polyline")

POLYGON

[`Polygon`](#redbrick.types.task.Polygon "redbrick.types.task.Polygon")

ELLIPSE

[`Ellipse`](#redbrick.types.task.Ellipse "redbrick.types.task.Ellipse")

BBOX

[`BoundingBox`](#redbrick.types.task.BoundingBox "redbrick.types.task.BoundingBox")

CUBOID

[`Cuboid`](#redbrick.types.task.Cuboid "redbrick.types.task.Cuboid")

_class_ redbrick.types.task.Point2D[#](#redbrick.types.task.Point2D "Link to this definition")

2D pixel point.

The Point2D coordinates are normalized in relation to the dimensions of the image, meaning they are scaled down to a range between 0 and 1. To convert these normalized points back to their original scale on the image, you “un-normalize” them by multiplying by the image’s dimensions. This operation typically results in a floating-point number.

RedBrick AI enhances the precision of annotations on its canvas by **supporting a resolution higher than that of the underlying image**. This capability facilitates sub-pixel annotation accuracy. However, if sub-pixel precision is not necessary for your application, you can simplify the process **by rounding the un-normalized coordinates to the nearest whole number**. This adjustment converts the precise floating-point values back to standard pixel coordinates, making them easier to work with for general purposes.

Important

The origin point (0,0) from which these coordinates are measured is at the top left of the image. However, for mammography and DBT the origin is the top right of the image.

xNorm_: `float`_[#](#redbrick.types.task.Point2D.xNorm "Link to this definition")

X co-ordinate normalized by the width of the image.

yNorm_: `float`_[#](#redbrick.types.task.Point2D.yNorm "Link to this definition")

Y co-ordinate normalized by the height of the image.

_class_ redbrick.types.task.VoxelPoint[#](#redbrick.types.task.VoxelPoint "Link to this definition")

Represents a three-dimensional point in image-space, where i, j, and k are columns, rows, and k is the slice number.

i_: `int`_[#](#redbrick.types.task.VoxelPoint.i "Link to this definition")

j_: `int`_[#](#redbrick.types.task.VoxelPoint.j "Link to this definition")

k_: `int`_[#](#redbrick.types.task.VoxelPoint.k "Link to this definition")

_class_ redbrick.types.task.WorldPoint[#](#redbrick.types.task.WorldPoint "Link to this definition")

Represents a three-dimensional point in physical space/world co-ordinates. The world co-ordinates are calculated using [`redbrick.types.task.VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint") and the DICOM Image Plane Module.

x_: `float`_[#](#redbrick.types.task.WorldPoint.x "Link to this definition")

y_: `float`_[#](#redbrick.types.task.WorldPoint.y "Link to this definition")

z_: `float`_[#](#redbrick.types.task.WorldPoint.z "Link to this definition")

_class_ redbrick.types.task.MeasurementStats[#](#redbrick.types.task.MeasurementStats "Link to this definition")

Measurement statistics for annotations.

average_: `float`_[#](#redbrick.types.task.MeasurementStats.average "Link to this definition")

Average pixel/voxel intensity within the annotation. In CT, this is the average HU value.

area_: `float`_[#](#redbrick.types.task.MeasurementStats.area "Link to this definition")

Area contained within the annotation in mm^2.

volume_: `float`_[#](#redbrick.types.task.MeasurementStats.volume "Link to this definition")

Volume contained within the annotation in mm^3

minimum_: `float`_[#](#redbrick.types.task.MeasurementStats.minimum "Link to this definition")

Minimum intensity value within the annotation.

maximum_: `float`_[#](#redbrick.types.task.MeasurementStats.maximum "Link to this definition")

Maximum intensity value within the annotation.

_class_ redbrick.types.task.VideoMetaData[#](#redbrick.types.task.VideoMetaData "Link to this definition")

Contains annotation information along the third axis. Frames for video, and slices for 3D volumes.

Warning

[`redbrick.types.task.VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData") has a misleading name. It contains information for both videos, and 3D volumes.

Hint

Watch [this video](https://share.redbrickai.com/vpKDGyBd) for a detailed explaination of all the attributes of this object.

seriesItemIndex_: `int`_[#](#redbrick.types.task.VideoMetaData.seriesItemIndex "Link to this definition")

The index of the file in series “items” list that this annotation is present on.

seriesFrameIndex_: `int`_[#](#redbrick.types.task.VideoMetaData.seriesFrameIndex "Link to this definition")

Frame index of the annotation for nifti and dicom multipart files.

frameIndex_: `int`_[#](#redbrick.types.task.VideoMetaData.frameIndex "Link to this definition")

The frame number (for video) or slice index (for 3D volumes) the annotation is present on.

trackId_: `str`_[#](#redbrick.types.task.VideoMetaData.trackId "Link to this definition")

Each distinct object has a unique trackId. Two annotations on different frameIndex’s with the same trackId’s represent the same distinct object.

keyFrame_: `bool`_[#](#redbrick.types.task.VideoMetaData.keyFrame "Link to this definition")

If True, this annotation is user-defined. If False, this annotation is interpolated.

endTrack_: `bool`_[#](#redbrick.types.task.VideoMetaData.endTrack "Link to this definition")

If True, this annotation is the last annotation of a specific track defined by trackId.

redbrick.types.task.Attributes[#](#redbrick.types.task.Attributes "Link to this definition")

Attributes for Taxonomy objects. Attributes can be boolean, textfields, select’s or multi-select’s.

alias of `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]

_class_ redbrick.types.task.CommonLabelProps[#](#redbrick.types.task.CommonLabelProps "Link to this definition")

Full version of [`redbrick.types.task.Series.segmentMap`](index.html#redbrick.types.task.Series.segmentMap "redbrick.types.task.Series.segmentMap").

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.CommonLabelProps.category "Link to this definition")

Taxonomy object category.

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.CommonLabelProps.attributes "Link to this definition")

Associated taxonomy object attributes.

mask_: `Union`\[`str`, `List`\[`str`\]\]_[#](#redbrick.types.task.CommonLabelProps.mask "Link to this definition")

Filepath to segmentation file for this annotation.

overlappingGroups_: `List`\[`int`\]_[#](#redbrick.types.task.CommonLabelProps.overlappingGroups "Link to this definition")

Overlapping instances that this label is part of (when without\_masks is set).

group_: `str`_[#](#redbrick.types.task.CommonLabelProps.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.CommonLabelProps.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.InstanceClassification[#](#redbrick.types.task.InstanceClassification "Link to this definition")

Instance level classifications for frame-by-frame (video) or slice-by-slice (volume) classifications..

fileIndex_: `int`_[#](#redbrick.types.task.InstanceClassification.fileIndex "Link to this definition")

For video this is the frameIndex, for DICOM volumes this is the sliceIndex.

fileName_: `str`_[#](#redbrick.types.task.InstanceClassification.fileName "Link to this definition")

The file name represented by frameIndex.

group_: `str`_[#](#redbrick.types.task.InstanceClassification.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.InstanceClassification.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Classification[#](#redbrick.types.task.Classification "Link to this definition")

Study or series classification.

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Classification.attributes "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Classification.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Classification.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Polyline[#](#redbrick.types.task.Polyline "Link to this definition")

Open polylines, not supported in 3D images.

points_: `List`\[[`Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D")\]_[#](#redbrick.types.task.Polyline.points "Link to this definition")

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Polyline.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Polyline.attributes "Link to this definition")

video_: [`VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData")_[#](#redbrick.types.task.Polyline.video "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Polyline.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Polyline.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Polygon[#](#redbrick.types.task.Polygon "Link to this definition")

Closed polygons, not supported in 3D images.

points_: `List`\[[`Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D")\]_[#](#redbrick.types.task.Polygon.points "Link to this definition")

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Polygon.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Polygon.attributes "Link to this definition")

stats_: [`MeasurementStats`](#redbrick.types.task.MeasurementStats "redbrick.types.task.MeasurementStats")_[#](#redbrick.types.task.Polygon.stats "Link to this definition")

video_: [`VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData")_[#](#redbrick.types.task.Polygon.video "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Polygon.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Polygon.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Cuboid[#](#redbrick.types.task.Cuboid "Link to this definition")

3D bounding boxes for 3D images.

point1_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.Cuboid.point1 "Link to this definition")

Top left diagonal corner.

point2_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.Cuboid.point2 "Link to this definition")

Bottom right diagonal corner.

absolutePoint1_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.Cuboid.absolutePoint1 "Link to this definition")

absolutePoint2_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.Cuboid.absolutePoint2 "Link to this definition")

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Cuboid.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Cuboid.attributes "Link to this definition")

stats_: [`MeasurementStats`](#redbrick.types.task.MeasurementStats "redbrick.types.task.MeasurementStats")_[#](#redbrick.types.task.Cuboid.stats "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Cuboid.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Cuboid.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.BoundingBox[#](#redbrick.types.task.BoundingBox "Link to this definition")

2D bounding box for 2D images, or slice by slice annotation in 3D images.

Hint

See the [following diagram](https://share.redbrickai.com/T0jPZFn9) to understand the coordinate system.

pointTopLeft_: [`Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D")_[#](#redbrick.types.task.BoundingBox.pointTopLeft "Link to this definition")

Coordinates of the top left of the bounding box.

wNorm_: `float`_[#](#redbrick.types.task.BoundingBox.wNorm "Link to this definition")

Width of the bounding box, normalized by image width.

hNorm_: `float`_[#](#redbrick.types.task.BoundingBox.hNorm "Link to this definition")

Height of the bounding box, normalized by the image height.

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.BoundingBox.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.BoundingBox.attributes "Link to this definition")

stats_: [`MeasurementStats`](#redbrick.types.task.MeasurementStats "redbrick.types.task.MeasurementStats")_[#](#redbrick.types.task.BoundingBox.stats "Link to this definition")

video_: [`VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData")_[#](#redbrick.types.task.BoundingBox.video "Link to this definition")

group_: `str`_[#](#redbrick.types.task.BoundingBox.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.BoundingBox.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Ellipse[#](#redbrick.types.task.Ellipse "Link to this definition")

Ellipse annotation.

Hint

See [this ellipse diagram](https://share.redbrickai.com/6PH9ypkl) to understand the coordinate system. Please read the [`redbrick.types.task.Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D") documentation to understand how normalization works & the origin of the coordinate system.

Warning

For DICOM images of a certain type, ellipse annotations might be flipped i.e., rotating the ellipse clockwise would result in counter-clockwise rotation. If you encounter these cases, reach out to our support for instructions on how to handle this [support@redbrickai.com](mailto:support%40redbrickai.com).

pointCenter_: [`Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D")_[#](#redbrick.types.task.Ellipse.pointCenter "Link to this definition")

The normalized center of the ellipse.

xRadiusNorm_: `float`_[#](#redbrick.types.task.Ellipse.xRadiusNorm "Link to this definition")

The x axis of the ellipse, normalized with by the image width. Adjusting for rotationRad, the x-axis of the ellipse aligns with the x-axis of the image.

yRadiusNorm_: `float`_[#](#redbrick.types.task.Ellipse.yRadiusNorm "Link to this definition")

The y axis of the ellipse, normalized with by the image width. Adjusting for rotationRad, the y-axis of the ellipse aligns with the y-axis of the image.

rotationRad_: `float`_[#](#redbrick.types.task.Ellipse.rotationRad "Link to this definition")

The rotation of the ellipse measured clockwise as the angle between the y-axis of the ellipse and y-axis of the image.

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Ellipse.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Ellipse.attributes "Link to this definition")

stats_: [`MeasurementStats`](#redbrick.types.task.MeasurementStats "redbrick.types.task.MeasurementStats")_[#](#redbrick.types.task.Ellipse.stats "Link to this definition")

video_: [`VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData")_[#](#redbrick.types.task.Ellipse.video "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Ellipse.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Ellipse.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.MeasureAngle[#](#redbrick.types.task.MeasureAngle "Link to this definition")

Angle measurement label.

An angle measurement is defined by three points, where vertex is the middle point between point1 and point2. The angle between the two vectors <point1, vertex> and <point2, vertex> defines the angle measurement.

Hint

See [this angle diagram](https://share.redbrickai.com/rqW3sZtf) to understand the coordinate system.

type_: `Literal`\[`'angle'`\]_[#](#redbrick.types.task.MeasureAngle.type "Link to this definition")

point1_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.MeasureAngle.point1 "Link to this definition")

vertex_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.MeasureAngle.vertex "Link to this definition")

point2_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.MeasureAngle.point2 "Link to this definition")

absolutePoint1_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.MeasureAngle.absolutePoint1 "Link to this definition")

absoluteVertex_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.MeasureAngle.absoluteVertex "Link to this definition")

absolutePoint2_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.MeasureAngle.absolutePoint2 "Link to this definition")

normal_: `List`\[`float`\]_[#](#redbrick.types.task.MeasureAngle.normal "Link to this definition")

Measurements can be made on oblique planes. normal defines the normal unit vector to the slice on which the annotation was made. For annotations made on non-oblique planes, the normal will be \[0,0,1\]. The measurement is fully defined even without normal, however, for completeness [see this angle diagram](https://share.redbrickai.com/CZ5BXXWK) for it’s definition.

angle_: `float`_[#](#redbrick.types.task.MeasureAngle.angle "Link to this definition")

Measurement angle in degrees.

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.MeasureAngle.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.MeasureAngle.attributes "Link to this definition")

group_: `str`_[#](#redbrick.types.task.MeasureAngle.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.MeasureAngle.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.MeasureLength[#](#redbrick.types.task.MeasureLength "Link to this definition")

Length measurement label.

A length measurement is defined by two points, and the length measurement is the distance between the two points.

type_: `Literal`\[`'length'`\]_[#](#redbrick.types.task.MeasureLength.type "Link to this definition")

point1_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.MeasureLength.point1 "Link to this definition")

point2_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.MeasureLength.point2 "Link to this definition")

absolutePoint1_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.MeasureLength.absolutePoint1 "Link to this definition")

absolutePoint2_: [`WorldPoint`](#redbrick.types.task.WorldPoint "redbrick.types.task.WorldPoint")_[#](#redbrick.types.task.MeasureLength.absolutePoint2 "Link to this definition")

normal_: `List`\[`float`\]_[#](#redbrick.types.task.MeasureLength.normal "Link to this definition")

Measurements can be made on oblique planes. normal defines the normal unit vector to the slice on which the annotation was made. For annotations made on non-oblique planes, the normal will be \[0,0,1\]. The measurement is fully defined even without normal, however, for completeness [see this length diagram](https://share.redbrickai.com/CZ5BXXWK) for it’s definition.

length_: `float`_[#](#redbrick.types.task.MeasureLength.length "Link to this definition")

The value of the measurement in millimeters.

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.MeasureLength.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.MeasureLength.attributes "Link to this definition")

group_: `str`_[#](#redbrick.types.task.MeasureLength.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.MeasureLength.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Landmark3D[#](#redbrick.types.task.Landmark3D "Link to this definition")

3D landmark for 3D data.

point_: [`VoxelPoint`](#redbrick.types.task.VoxelPoint "redbrick.types.task.VoxelPoint")_[#](#redbrick.types.task.Landmark3D.point "Link to this definition")

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Landmark3D.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Landmark3D.attributes "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Landmark3D.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Landmark3D.readOnly "Link to this definition")

Read only status

_class_ redbrick.types.task.Landmark[#](#redbrick.types.task.Landmark "Link to this definition")

2D landmark for 2D data.

point_: [`Point2D`](#redbrick.types.task.Point2D "redbrick.types.task.Point2D")_[#](#redbrick.types.task.Landmark.point "Link to this definition")

category_: `Union`\[`int`, `str`, `List`\[`str`\]\]_[#](#redbrick.types.task.Landmark.category "Link to this definition")

attributes_: `Dict`\[`str`, `Union`\[`str`, `bool`, `List`\[`str`\]\]\]_[#](#redbrick.types.task.Landmark.attributes "Link to this definition")

video_: [`VideoMetaData`](#redbrick.types.task.VideoMetaData "redbrick.types.task.VideoMetaData")_[#](#redbrick.types.task.Landmark.video "Link to this definition")

group_: `str`_[#](#redbrick.types.task.Landmark.group "Link to this definition")

Linked label group id.

readOnly_: `bool`_[#](#redbrick.types.task.Landmark.readOnly "Link to this definition")

Read only status

##### Taxonomy format[#](#module-redbrick.types.taxonomy "Link to this heading")

Section covering the formats for all Taxonomy objects. Taxonomies define a labeling schema for your RedBrick AI projects.

_class_ redbrick.types.taxonomy.AttributeOption[#](#redbrick.types.taxonomy.AttributeOption "Link to this definition")

Attribute Option.

name_: `str`_[#](#redbrick.types.taxonomy.AttributeOption.name "Link to this definition")

optionId_: `int`_[#](#redbrick.types.taxonomy.AttributeOption.optionId "Link to this definition")

color_: `str`_[#](#redbrick.types.taxonomy.AttributeOption.color "Link to this definition")

archived_: `bool`_[#](#redbrick.types.taxonomy.AttributeOption.archived "Link to this definition")

_class_ redbrick.types.taxonomy.Attribute[#](#redbrick.types.taxonomy.Attribute "Link to this definition")

Attribute.

name_: `str`_[#](#redbrick.types.taxonomy.Attribute.name "Link to this definition")

attrType_: `Literal`\[`'BOOL'`, `'TEXT'`, `'SELECT'`, `'MULTISELECT'`\]_[#](#redbrick.types.taxonomy.Attribute.attrType "Link to this definition")

attrId_: `int`_[#](#redbrick.types.taxonomy.Attribute.attrId "Link to this definition")

options_: `Optional`\[`List`\[[`AttributeOption`](#redbrick.types.taxonomy.AttributeOption "redbrick.types.taxonomy.AttributeOption")\]\]_[#](#redbrick.types.taxonomy.Attribute.options "Link to this definition")

For attrType SELECT and MULTISELECT this defines the list of selection options.

archived_: `bool`_[#](#redbrick.types.taxonomy.Attribute.archived "Link to this definition")

parents_: `Optional`\[`List`\[`str`\]\]_[#](#redbrick.types.taxonomy.Attribute.parents "Link to this definition")

Defining parents will add a nested structure to the taxonomy. Multiple attributes with parent \[“Type A”\] will be visually nested under a expansion panel Type A in the user interface.

Note

Only supported for Classifications, not for Object Attributes.

hint_: `Optional`\[`str`\]_[#](#redbrick.types.taxonomy.Attribute.hint "Link to this definition")

A string containing raw text, or HTML. The hints will appear in the viewer.

defaultValue_: `Union`\[`str`, `bool`, `int`, `List`\[`int`\], `None`\]_[#](#redbrick.types.taxonomy.Attribute.defaultValue "Link to this definition")

For SELECT or MULTISELECT types, defaultValue will pre-populate the UI with the selection.

_class_ redbrick.types.taxonomy.ObjectType[#](#redbrick.types.taxonomy.ObjectType "Link to this definition")

Object’s are used to annotate features or objects in tasks.

category_: `str`_[#](#redbrick.types.taxonomy.ObjectType.category "Link to this definition")

Category of the Taxonomy object is a string descriptor.

classId_: `int`_[#](#redbrick.types.taxonomy.ObjectType.classId "Link to this definition")

A unique integer for this object. Segmentation files can be exported to contain classId as the values in the file.

labelType_: `Literal`\[`'BBOX'`, `'CUBOID'`, `'POINT'`, `'POLYLINE'`, `'POLYGON'`, `'ELLIPSE'`, `'SEGMENTATION'`, `'LENGTH'`, `'ANGLE'`\]_[#](#redbrick.types.taxonomy.ObjectType.labelType "Link to this definition")

They type of label for this object.

attributes_: `Optional`\[`List`\[[`Attribute`](#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]\]_[#](#redbrick.types.taxonomy.ObjectType.attributes "Link to this definition")

Attributes allow further classification of objects.

color_: `str`_[#](#redbrick.types.taxonomy.ObjectType.color "Link to this definition")

archived_: `bool`_[#](#redbrick.types.taxonomy.ObjectType.archived "Link to this definition")

parents_: `Optional`\[`List`\[`str`\]\]_[#](#redbrick.types.taxonomy.ObjectType.parents "Link to this definition")

Defining parents will add a nested structure to the taxonomy. Multiple objects with parent \[“Type A”\] will be visually nested under a expansion panel Type A in the user interface.

hint_: `Optional`\[`str`\]_[#](#redbrick.types.taxonomy.ObjectType.hint "Link to this definition")

A string containing raw text, or HTML. The hints will appear in the viewer.

_class_ redbrick.types.taxonomy.Taxonomy[#](#redbrick.types.taxonomy.Taxonomy "Link to this definition")

Taxonomy object.

orgId_: `str`_[#](#redbrick.types.taxonomy.Taxonomy.orgId "Link to this definition")

taxId_: `str`_[#](#redbrick.types.taxonomy.Taxonomy.taxId "Link to this definition")

name_: `str`_[#](#redbrick.types.taxonomy.Taxonomy.name "Link to this definition")

studyClassify_: `List`\[[`Attribute`](#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]_[#](#redbrick.types.taxonomy.Taxonomy.studyClassify "Link to this definition")

seriesClassify_: `List`\[[`Attribute`](#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]_[#](#redbrick.types.taxonomy.Taxonomy.seriesClassify "Link to this definition")

instanceClassify_: `List`\[[`Attribute`](#redbrick.types.taxonomy.Attribute "redbrick.types.taxonomy.Attribute")\]_[#](#redbrick.types.taxonomy.Taxonomy.instanceClassify "Link to this definition")

objectTypes_: `List`\[[`ObjectType`](#redbrick.types.taxonomy.ObjectType "redbrick.types.taxonomy.ObjectType")\]_[#](#redbrick.types.taxonomy.Taxonomy.objectTypes "Link to this definition")

createdAt_: `str`_[#](#redbrick.types.taxonomy.Taxonomy.createdAt "Link to this definition")

archived_: `bool`_[#](#redbrick.types.taxonomy.Taxonomy.archived "Link to this definition")

isNew_: `bool`_[#](#redbrick.types.taxonomy.Taxonomy.isNew "Link to this definition")

Copyright © 2023, RedBrick AI

Made with [Sphinx](https://www.sphinx-doc.org/) and [@pradyunsg](https://pradyunsg.me)'s [Furo](https://github.com/pradyunsg/furo)

On this page

*   [Python SDK](index.html#document-sdk)
    *   [RedBrick](index.html#module-redbrick)
    *   [Organization](index.html#organization)
    *   [Team](index.html#team)
    *   [Storage](index.html#storage)
    *   [Workspace](index.html#workspace)
    *   [Project](index.html#project)
    *   [Export](index.html#export)
    *   [Upload](index.html#upload)
    *   [Labeling](index.html#labeling)
    *   [Settings](index.html#settings)
    *   [Workforce](index.html#workforce)

*   [Command Line Interface](index.html#document-cli)
    *   [Named Arguments](index.html#named-arguments)
    *   [Commands](index.html#commands)
    *   [Sub-commands](index.html#Sub-commands)

*   [Formats](index.html#document-formats/index)
    *   [Import](index.html#import)
    *   [Export](index.html#export)
